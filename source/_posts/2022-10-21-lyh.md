---
title:  LYHDP选做
subtitle: 总有一天...
layout: post
show: false
istop: false
tags: 
- 咕咕
---

# LYHDP

## Day6-slide.pdf

数数题默认膜998244353.

### CF1408G Clusterization Counting

> 给定 $n$ 点带权无向联通图,求把其划分成 $k$ 个不交的组的方案,满足任意 $s,f,x,y$ 中若 $s,f,x$ 同组, $y$ 与 $x$ 不同组,则 $w_{x,y}>w_{s,f}$
> 
> 对 $1\ldots n$ 的每个 $k$ 输出答案.
> 
> $n\le 1500$

考虑这个限制的实际含义是组内边大于组间边~~(然后用形式化题意恶心人)~~.

于是考虑直接按边权递增加边,相同边权一起加,那么每个组必然是出现过的连通块.

考虑连通块的总个数,发现若形成新的连通块必然要加入新点和已有合并,只有 $O(n)$ 个.

于是把 $O(n)$ 个连通块的包含关系建树,那么问题就成了在树上选 $k$ 个没有祖先关系的点的方案数.

考虑dp, $f_{u,i}$ 表示 $u$ 子树内选了 $k$ 个即可.

[think] 把限制变成更实际意义的形式理解
[think] 不交的关系在包含关系的树上(父亲代表的集合包含儿子)表示为树上没有祖先关系

### CF1383E Strange Operation

> 有一个长度为 $n$ 的 $01$ 串 $s$ ,可以对该串进行若干次操作,每次操作可以将两个相邻的数字合并为两者的最大值(操作之后字符串长度减少 $1$ ).问操作后有多少种可能的字符串.
> 
> $n \le 10^6$

考虑合并操作实质是让一个连续0段或1段缩短一个,但1段不会消失,0段有可能消失.

那么考虑判定串 $t$ 可以被 $s$ 得到,从头开始扫,如果当前0段长度大于 $s$ 的0段,那么认为 $s$ 的这个段被消没了接着往下匹配,如果当前1段大于 $s$ 的1段,那么认为下一个0段被消没了打通到下一个,这么贪心的匹配.

那么考虑dp方案,用dpofdp的思想,内层状态只需要记录 $t$ 是0/1段,长多少和 $s$ 的一段长多少,显然是过不了的.

毫无用处.

看题解,它用 $a_i$ 表示 $s$ 第 $i$ 个1和第 $i+1$ 个1之间0的个数,认为可以得到叫包含,则设 $f_i$ 表示 $a_1\ldots a_i$ 能够,而更小的前缀无法包含的序列个数.假设能包含的序列最后一项是 $x$ ,那 $x$ 肯定与 $a_i$ 对应,考虑如果上一项对应 $a_j$ ,那么 $i,j$ 之间的 $a_k$ 都要小于 $x$ 不然就能被更短的包含了.于是要找到最大的 $a_k\ge x$ 的 $k$ , $x$ 的方案就直接区间和.复杂度线性.

然后再处理点边界,如果 $s$ 只有0是简单的,并且假设 $s$ 最后最前分别有 $x,y$ 个0,那么可以把它们剥去,最后乘上 $(x+1)(y+1)$ ,用两边都是1的做.

[think] 感觉就是,当我们知道如何数数的时候,可以思考一个状态数 $O(1)$ 的判定,把它塞到dp里.

### CF1372E Omkar and Last Floor

> 给一个 $n\times m$ 的网格,每一行被分成若干块,要把格子里填满0/1,每个块内仅有一个1,最大化 $\sum {q_i}^2$ ,其中 $q_i$ 为第 $i$ 咧的元素和.
> 
> $n,m\le 100$

考虑一定会让最多的列填满.

那么至少让一列填满.填满的这一列可以把它分成两半,每一半结论相同.

那么区间dp,设 $f_{l,r}$ 表示 $[l,r]$ 完整包含的块的答案,那么枚举一个满的列分成两边就行了.注意只要完整包含是因为如果没有完整包含一定在其他地方有了1.

### CF1366G Construct the String

> 给定一个包含小写字母和 $\texttt{.}$ 串 $s$ , $\texttt{.}$ 表示backspace,按顺序按下这些按键,空串再删会崩溃,求删除最少的字符使得结果为 $t$ 且不崩溃.
> 
> $\vert t\vert\le \vert s\vert \le 10^4$

$f_{i,j}$ 表示 $s$ 的前 $i$ 个,匹配 $t$ 的前 $j$ 个都最小代价.能转移吗?

如果当前字符是 $\texttt{.}$ ,不会转移.

设 $f_{i,j}$ 表示前 $i$ 个删 $j$ 个得到 $t$ 的最长长度,能转移吗?

如果当前字符是 $\texttt{.}$ ,也不会转移.

哦第一个是可以转移的啊.考虑如果一个区间如果执行完是空的,那么就可以从这个区间前转移,预处理每个位置从哪里转移过来是简单的.

[think] 考虑dp的转移的时候思维还是太局限,**要枚举尝试从多个维度上跳跃的转移过来的可能性**.

### CF1342F Make It Ascending

> 给一个长度为 $n$ 的序列 $a$ ,你可以若干次选择 $i\ne j$ ,让 $a_j:=a_j+a_i$ 并删除 $a_i$ ,用尽可能的操作将序列变成严格增.
> 
> $n\le 15$

$n\le 15$ ,但没有那么高妙,只要猜状态.

考虑题目是要你选若干个集合,和递增,且每个集合选择其中的一个元素的位置递增,且选的集合尽量多.

那你就设 $f_{S,i,j}$ 已经选了集合 $S$ ,已经选了 $i$ 个集合,然后最后一个集合的元素的位置是 $j$ 的情况下最后一个集合的和的最小值.

状态好像挺自然?小于20的dp要使劲设!

### CF1326F2 Wise Men (Hard Version)

> 给定一个 $n$ 个点的无向图,对于一个排列 $p_n$ ,对应一个 $01$ 序列 $a_{n-1}$ ,其中 $a_i$ 表示 $p_i$ 和 $p_{i+1}$ 之间是否有边,给出图,求对于每个01序列对应多少排列.
> 
> $n\le 18$

居然是容斥题.

考虑限制是第 $i$ 位为1或无所谓,求方案数,那么只要容斥就能得到答案了.把这个得到的用FMT可以得到答案.

那么现在一个限制串 $s$ , $s_i$ 为1表示这一位必须为1,否则任意,那么其中的0将1分成若干段,每一段内必须有边,段间随便走.

那么每一段的大小加一(长 $k$ 的段决定排列中长 $k+1$ 的区间中路径必须都走有边的)构成的可重集相同的 $s$ 答案相同.原因是考虑:段间不做要求所以两个段可以任意互换.

于是对每个可重集求答案.因为可重集总和是 $n$ ,所以只有18的划分数大概不到400种情况.

[?] 对每个可重集求答案,可以直接选取可重集中的任意一个限制串求,那么设 $f_{S,i}$ 表示走过集合 $S$ ,当前走到 $i$ 的方案数去dp.

奇怪,大家的做法好像都是处理长度为 $i$ ,走过 $S$ 中点的方案数 $g_{i,S}$ ,然后把对应 $g_i$ 拿出来跑卷积.

![picture 2](/img/2022-10-21-20-05-27-image.png)  

### CF1290F Making Shapes

> 给定 $n$ 个向量,你可以把它们接起来走回原点得到多边形,求这个多边形是凸的且可以被 $m\times m$ 的矩形框住的方案数.不同位置的凸多边形算不同的.
> 
> $n\le 5,m\le 10^9,x_i,y_i\in [-4,4]$

考虑实际上多边形的形状仅取决于每种向量的个数,因为凸多边形意味着我们对向量极角排序.

于是问题变成确定每组向量个数使得它们两个方向上和为0.设个数分别是 $c_1,c_2,\ldots,c_n$

这个东西很难做,因为它们的数量实在太大.考虑**逐位确定个数**,设 $f_{i,0/1,0/1,0/1,0/1,0/1,0/1}$ 表示 $x,y$ 与 $m$ 在前 $i$ 位的大小关系,进位和正负,每次枚举 $n$ 个 $c$ 在下一位是0/1的 $2^n$ 种情况.

[think] 逐位确定个数,用类似数位dp的方法设计状态,用在值域大,且我们关心的性质相对简单(比如这里只是大小关系)

## slide.pptx

上面那个做不动啊,还是看看简单点的.

### CF1409F Subsetsequences of Length Two

> 给定 $s_n,t_2$ ,可以修改 $s$ 的最多 $k$ 个字符使得 $t$ 作为子序列在 $s$ 中出现次数最大.
> 
> $n\le 200$

$f_{i,j,k,l}$ 表示前 $i$ 个,修改 $j$ 个, $t_1$ , $t_2$ 的个数分别为 $k,l$ 的 $t$ 出现次数.

哦, $t_1,t_2$ 只需要记录一个.

### CF1404B Tree Tag 

> 给定一棵树 $T=Tree(n)$ , $AB$ 初始时在 $a,b$ 两点,每次可以移动到距离不超过 $d_a,d_b$ 的点,交替移动 $A$ 先手,若 $A$ 能抓住 $B$ , $A$ 获胜.问谁赢.
> $n\le 10^5$ .

考虑因为无限步数,可以忽略前面过程,直接想什么时候必然抓住:

- $A$ 站在直径中点上, $B$ 死了
- $d_b\le 2d_a$ ,此时它不能跨过 $A$ ,那 $A$ 只要一步一步压缩即可.
- 一开始 $B$ 离 $A$ 太近

### CF1349C Orac and Game of Life

> 给定 $n\times m$ 01矩阵,每次若一个位置与它四连通的位置01相同就取反, $q$ 次询问 $i,j$ 在 $p$ 秒后是几.
> 
> $n,m\le 1000,t\le 10^5,p\le 10^18$

一个连通块总是同步的,可以缩起来.

如果一个格子某一时刻变了,那么它接着会一直变.

于是直接求每个格子最早的变化时间(容易发现非常早),bfs一遍转移.

### CF1338B Edge Weight Assignment

> 给定无根树 $Tree(n)$ ,为每条边赋值 $w>0$ ,使得任意两个叶子路径异或和为0,求最少最多的颜色数.
> 
> $n\le 10^5$

要求任意两个叶子中所有数出现偶数次,那最少的情况显然可以中间的全相等,在叶子上调整(再找两个数异或等于刚才的数一调就行了).

最多的情况,考虑一个点的所有叶子儿子到它的边要相同,除了这个之外都可以不同(初始化一个相同的解,然后在非常高的位置调整出一个1)

### CF1334D Minimum Euler Cycle

> 给定 $n$ 点的有向完全图(任意两点之间有两条边),求字典序最小的欧拉回路的第 $l$ 到第 $r$ 个点.
> 
> $n\le 10^5$

出发位置是最小值,以后每次走出边最小的就是策略了.

考虑这么做形成若干个环,对每个点统计这里出发的环的大小?不对.

降智,正确做法:完全图,所以实际上你可以任意走,要保证每条边正反各一次,直接构造:

$1\to 2\to 1\to 3\to \ldots 1\to n\to 2\to 3\to 2\ldots$

### CF1329A Dreamoon Likes Coloring

> 给定 $a_n$ ,进行 $m$ 次区间 $l_i,r_i$ 赋值,要求最后每个颜色出现至少一次,每个格子都有颜色. $l_i$ 给定, $r_i$ 不给定.
> 
> $n,m\le 10^5$

考虑直接把 $l$ 对应 $r$ 排序然后随便模拟.

### CF1322B Present

> 给定 $a_n$ ,求 $a$ 中任意两数对的和的异或和.
> 
> $n\le 4\times 10^5,a_i\le 10^7$

每一位分别考虑,要求一个数与其他所有数在第 $i$ 位上为 $1$ 的个数.两种情况:要么是直接加的,要么是进位出来的.

进位就是每个数只取前 $k-1$ 位,加起来小于 $2^k$ ,于是可以直接做了.

### CF1320C Battle for Azathoth

矩形加-最大矩形和,扫掉一维即可.

### CF1312E Array Shrinking

直接区间dp,注意若一个区间可以合并成单点,这个数是唯一的.

### CF1288D Minimax Problem

二分答案+变成一堆二进制数或起来全1+FMT.想不到吧,是可以直接枚举两个二进制数的(值域很小)

### CF1276B Two Fairs

$a,b$ 是割点,于是图分成三部分,答案是两边两部分的积.

哦, $a,b$ 不一定是割点,而是删掉它们之后, $u,v$ 是分别和 $u,v$ 相连的两部分.

### CF1213G Path Queries

离线排序从小到大,问连通块平方和之类的.

### CF1030E Vasya and Good Sequences

可以对每个数都把一整到最前面,一定不劣?不对,比如6,7,14这个样的,你会让它们下面的抵消,最后用6消掉上面的.

于是实际条件是,1的个数为偶数,并且最大的数的1的个数不超过总共个数的一半,发现不满足第二个限制的区间最长是 $w$ 的,于是暴力即可.

### CF959E Mahmoud and Ehab and the xor-MST

异或和为1的会连接任意 $2i,2i+1$ .

异或和为2的会连接差2的点.

发现加入异或和为 $2^i$ 的会合并前 $2^i$ 位,其他的不会合并.

于是答案就是

$$
\sum_i \lfloor \dfrac{n}{2^i*2} \rfloor 2^i
$$

### CF900D Unusual Sequences

都除以 $x$ ,问题变成互质序列加起来是 $\dfrac{y}{x}$ 的方案数.

没有互质可以直接隔板法是 $2^{y-1}$ .于是你就容斥, $g(x)$ 表示 $\gcd$ 为 $x$ 的因数的方案数, $f(x)$ 表示恰好为 $x$ 的方案数,莫反即可.

### CF859D Third Month Insanity

直接dp,一遍算在点 $u$ , $x$ 获胜的概率,一遍dp点 $u$ 子树内走到 $u$ 的是 $i$ 的情况下得分期望和.

### CF853C Boredom

简单容斥+二维数点

### CF1408E Avoid Rainbow Cycles

考虑把图简化,一个集合连一个团可以变为给每个集合建一个点,集合内的点向它连边.

此时原边权是现在两条边中间那个点的点权.

发现因为集合每个点多颜色是唯一的,这样做又不会形成同集合的环,所以只要有环就是rainbow.

然后开始想什么网络流建图可以约束没有环这一条件,哦,是最大生成树啊/hanx.

### CF1217E Sum Queries?

> 给你 $n$ 个数 $a_i$ .
> 对于一个子序列 $p$ ,定义 $s_p$ 为子序列中所有数的和.
> 定义一个子序列 $p$ 是好的,当且仅当 $s_p$ 用十进制表示时,对于 $\forall i$ ,都能在子序列 $p$ 中找到一个数 $x$ , 使得 $s_p$ 从低到高的第 $i$ 位与 $x$ 从低到高的第 $i$ 位相等.
> 你需要对序列 $a$ 做 $2$ 种操作:
> 1. 把 $a_i$ 修改成 $x$ .
> 2. 在 $a_l,a_{l+1}\cdots,a_r$ 构成的序列中,找一个 $s_p$ 最小的子序列 $p$ ,使得 $p$ 是坏的.你需要输出 $s_p$ .如果不存在,输出 $-1$ .
> $1\le n,m\le 10^5,1\le x,a_i<10^9$

考虑如果一个集合是坏只要有一位不全为0.于是随便维护.

### CF1215E Marbles

> 有 $n (n \le 4 * 10^5)$ 个珠子 , 第 $i$ 个珠子颜色是 $c_i (c_i \le 20)$ , 每次操作把**相邻**的两个珠子交换.现在要把相同颜色的珠子排列在相连的一段,问至少要多少次操作 .

给珠子钦定一个顺序之后就是排序了,排序是好做的.

那么设 $cost(a,b)$ 表示 $a$ 排在 $b$ 之后的代价,直接状压dp即可.

### CF1188C Array Beauty

> 定义一个序列 $b_1, \ldots, b_n$ 的美丽值为 $\min_{1 \leq i < j \leq n}\{\vert b_i-b_j\vert \}$ .给定一个长度为 $n$ 的序列 $a$ ,求 $a$ 的所有长度为 $k$ 的子序列的美丽值之和对 $998244353$ 取模的结果.
> $2 \leq k \leq n \leq 1000$ , $0 \leq a_i \leq 10^5$ .

先枚举一个美丽值,计算有多少个子集.

把$a$排序.

$f_{i,j}$表示$a$的前$i$个里选$j$个,美丽值大于当前值的方案数,复杂度$n^2$.或者确切的,$nk$

似乎过不了,但是你再想想,值域其实不是$\max a_i$,而是$\dfrac{\max a_i}{k - 1}$!你就过了.

[think] 分析复杂度确切一点!

### CF1111E Tree

> 给定 $Tree(n)$ , $q$ 次询问给定 $k,m,r,a_k$ ,求将 $a_k$ 中点分为不超过 $m$ 组使得以 $r$ 为根的时候没有同组两点有祖先关系的方案数.膜 $10^9+7$
> 
> $n,q\le 10^5,m\le \min(k,300)$

直接虚树dp, $f_{i,j}$ 表示以 $i$ 的子树内分 $j$ 组的方案. 问题是合并两个子树信息的时候,可能有跨过子树的组,我们也不知道怎么办了(

枚举扫描线方向,子树dp相当于从儿子到祖先,考虑先祖先再儿子,于是想到dfs序排序,设 $f_{i,j}$ 表示前 $i$ 个点,分 $j$ 组,那么点 $i$ 的不能和它的祖先一组,可以挤进去或者新开一组,简单 $nk$ .

那么现在也不用虚树了,只要求有多少个祖先是关键点,简单单点加链求和.

但实际上手够硬也是可以的,考虑一开始组带着标号算,并且允许空组,此时两个子树合并的时候就是直接 $f_{i,j}$ 相乘,因为就相当于一共有这么多组,每次把一个子树的东西填进去,合并两个子树的时候就是直接对应相乘,容斥出非空盒子个数除掉阶乘即可.复杂度相同.

[think] 树上dp的扫描线方向,带标号简化问题+容斥.

### CF1097D Makoto and a Blackboard

> 给定 $n,k$，一共会进行 $k$ 次操作，每次操作会把 $n$ 等概率的变成 $n$ 的某个约数
> 求操作 $k$ 次后 $n$ 的期望是多少，答案对 $10^9+7$ 取模
> $1 \le n \le 10^{15},1 \le k \le 10^4$

显然$n$只有$\log n$段.考虑对这个计数,枚举一个$n$的约数,再枚举$n$到这个约数之间有多少段,隔板算方案数,但这是错误的,那个多少段根本没法数.

考虑把$n$质因数分解,发现答案关于每个因子$p^a$是独立的,此时就可以直接计算了.

[think] 计数要找独立!独立!

### CF1044D Deduction Queries

> 给定$a_n$和$q$次操作$(1 \leq q \leq 2 \times 10^5)$，两种操作类型：
> `1,l,r,x`：表示已知$a$的区间$[l,r]$的异或和为$x$,或者与已知矛盾忽略.
> `2,l,r`：表示询问$a[l,r]$的异或和或判断不可知.
> 强制在线。$(0 \leq l,r,x \leq 2^{30})$

它确实张了一张并查集的脸啊!

考虑带权并查集,每个点维护到根的点的异或和,就行了.

### CF1043F Make It One

在数数题里.

### CF891C Envy

> 给出一个$ n $ 个点$ m $条边的无向图，每条边有边权，共$ Q $次询问，每次给出$ k_i $条边，问这些边能否同时在一棵最小生成树上。
> 
> $n,m,q,w,\sum k_i\le 5\times 10^5$

问题等价于,对于这$k_1$条边,不存在一个链$u\to \ldots\to v$满足存在$e=u\to v$且$e_w$比链的最小值更小.



