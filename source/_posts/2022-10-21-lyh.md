---
title:  LYHDP选做
subtitle: 总有一天...
layout: post
show: false
istop: false
tags: 
- 咕咕
---

# LYHDP

## Day6-slide.pdf

数数题默认膜998244353.

### CF1408G Clusterization Counting

> 给定 $n$ 点带权无向联通图,求把其划分成 $k$ 个不交的组的方案,满足任意 $s,f,x,y$ 中若 $s,f,x$ 同组, $y$ 与 $x$ 不同组,则 $w_{x,y}>w_{s,f}$
> 
> 对 $1\ldots n$ 的每个 $k$ 输出答案.
> 
> $n\le 1500$

考虑这个限制的实际含义是组内边大于组间边~~(然后用形式化题意恶心人)~~.

于是考虑直接按边权递增加边,相同边权一起加,那么每个组必然是出现过的连通块.

考虑连通块的总个数,发现若形成新的连通块必然要加入新点和已有合并,只有 $O(n)$ 个.

于是把 $O(n)$ 个连通块的包含关系建树,那么问题就成了在树上选 $k$ 个没有祖先关系的点的方案数.

考虑dp, $f_{u,i}$ 表示 $u$ 子树内选了 $k$ 个即可.

[think] 把限制变成更实际意义的形式理解
[think] 不交的关系在包含关系的树上(父亲代表的集合包含儿子)表示为树上没有祖先关系

### CF1383E Strange Operation

> 有一个长度为 $n$ 的 $01$ 串 $s$ ,可以对该串进行若干次操作,每次操作可以将两个相邻的数字合并为两者的最大值(操作之后字符串长度减少 $1$ ).问操作后有多少种可能的字符串.
> 
> $n \le 10^6$

考虑合并操作实质是让一个连续0段或1段缩短一个,但1段不会消失,0段有可能消失.

那么考虑判定串 $t$ 可以被 $s$ 得到,从头开始扫,如果当前0段长度大于 $s$ 的0段,那么认为 $s$ 的这个段被消没了接着往下匹配,如果当前1段大于 $s$ 的1段,那么认为下一个0段被消没了打通到下一个,这么贪心的匹配.

那么考虑dp方案,用dpofdp的思想,内层状态只需要记录 $t$ 是0/1段,长多少和 $s$ 的一段长多少,显然是过不了的.

毫无用处.

看题解,它用 $a_i$ 表示 $s$ 第 $i$ 个1和第 $i+1$ 个1之间0的个数,认为可以得到叫包含,则设 $f_i$ 表示 $a_1\ldots a_i$ 能够,而更小的前缀无法包含的序列个数.假设能包含的序列最后一项是 $x$ ,那 $x$ 肯定与 $a_i$ 对应,考虑如果上一项对应 $a_j$ ,那么 $i,j$ 之间的 $a_k$ 都要小于 $x$ 不然就能被更短的包含了.于是要找到最大的 $a_k\ge x$ 的 $k$ , $x$ 的方案就直接区间和.复杂度线性.

然后再处理点边界,如果 $s$ 只有0是简单的,并且假设 $s$ 最后最前分别有 $x,y$ 个0,那么可以把它们剥去,最后乘上 $(x+1)(y+1)$ ,用两边都是1的做.

[think] 感觉就是,当我们知道如何数数的时候,可以思考一个状态数 $O(1)$ 的判定,把它塞到dp里.

### CF1372E Omkar and Last Floor

> 给一个 $n\times m$ 的网格,每一行被分成若干块,要把格子里填满0/1,每个块内仅有一个1,最大化 $\sum {q_i}^2$ ,其中 $q_i$ 为第 $i$ 咧的元素和.
> 
> $n,m\le 100$

考虑一定会让最多的列填满.

那么至少让一列填满.填满的这一列可以把它分成两半,每一半结论相同.

那么区间dp,设 $f_{l,r}$ 表示 $[l,r]$ 完整包含的块的答案,那么枚举一个满的列分成两边就行了.注意只要完整包含是因为如果没有完整包含一定在其他地方有了1.

### CF1366G Construct the String

> 给定一个包含小写字母和 $\texttt{.}$ 串 $s$ , $\texttt{.}$ 表示backspace,按顺序按下这些按键,空串再删会崩溃,求删除最少的字符使得结果为 $t$ 且不崩溃.
> 
> $\vert t\vert\le \vert s\vert \le 10^4$

$f_{i,j}$ 表示 $s$ 的前 $i$ 个,匹配 $t$ 的前 $j$ 个都最小代价.能转移吗?

如果当前字符是 $\texttt{.}$ ,不会转移.

设 $f_{i,j}$ 表示前 $i$ 个删 $j$ 个得到 $t$ 的最长长度,能转移吗?

如果当前字符是 $\texttt{.}$ ,也不会转移.

哦第一个是可以转移的啊.考虑如果一个区间如果执行完是空的,那么就可以从这个区间前转移,预处理每个位置从哪里转移过来是简单的.

[think] 考虑dp的转移的时候思维还是太局限,**要枚举尝试从多个维度上跳跃的转移过来的可能性**.

### CF1342F Make It Ascending

> 给一个长度为 $n$ 的序列 $a$ ,你可以若干次选择 $i\ne j$ ,让 $a_j:=a_j+a_i$ 并删除 $a_i$ ,用尽可能的操作将序列变成严格增.
> 
> $n\le 15$

$n\le 15$ ,但没有那么高妙,只要猜状态.

考虑题目是要你选若干个集合,和递增,且每个集合选择其中的一个元素的位置递增,且选的集合尽量多.

那你就设 $f_{S,i,j}$ 已经选了集合 $S$ ,已经选了 $i$ 个集合,然后最后一个集合的元素的位置是 $j$ 的情况下最后一个集合的和的最小值.

状态好像挺自然?小于20的dp要使劲设!

### CF1326F2 Wise Men (Hard Version)

> 给定一个 $n$ 个点的无向图,对于一个排列 $p_n$ ,对应一个 $01$ 序列 $a_{n-1}$ ,其中 $a_i$ 表示 $p_i$ 和 $p_{i+1}$ 之间是否有边,给出图,求对于每个01序列对应多少排列.
> 
> $n\le 18$

居然是容斥题.

考虑限制是第 $i$ 位为1或无所谓,求方案数,那么只要容斥就能得到答案了.把这个得到的用FMT可以得到答案.

那么现在一个限制串 $s$ , $s_i$ 为1表示这一位必须为1,否则任意,那么其中的0将1分成若干段,每一段内必须有边,段间随便走.

那么每一段的大小加一(长 $k$ 的段决定排列中长 $k+1$ 的区间中路径必须都走有边的)构成的可重集相同的 $s$ 答案相同.原因是考虑:段间不做要求所以两个段可以任意互换.

于是对每个可重集求答案.因为可重集总和是 $n$ ,所以只有18的划分数大概不到400种情况.

[?] 对每个可重集求答案,可以直接选取可重集中的任意一个限制串求,那么设 $f_{S,i}$ 表示走过集合 $S$ ,当前走到 $i$ 的方案数去dp.

奇怪,大家的做法好像都是处理长度为 $i$ ,走过 $S$ 中点的方案数 $g_{i,S}$ ,然后把对应 $g_i$ 拿出来跑卷积.

![picture 2](/img/2022-10-21-20-05-27-image.png)  

### CF1290F Making Shapes

> 给定 $n$ 个向量,你可以把它们接起来走回原点得到多边形,求这个多边形是凸的且可以被 $m\times m$ 的矩形框住的方案数.不同位置的凸多边形算不同的.
> 
> $n\le 5,m\le 10^9,x_i,y_i\in [-4,4]$

考虑实际上多边形的形状仅取决于每种向量的个数,因为凸多边形意味着我们对向量极角排序.

于是问题变成确定每组向量个数使得它们两个方向上和为0.设个数分别是 $c_1,c_2,\ldots,c_n$

这个东西很难做,因为它们的数量实在太大.考虑**逐位确定个数**,设 $f_{i,0/1,0/1,0/1,0/1,0/1,0/1}$ 表示 $x,y$ 与 $m$ 在前 $i$ 位的大小关系,进位和正负,每次枚举 $n$ 个 $c$ 在下一位是0/1的 $2^n$ 种情况.

[think] 逐位确定个数,用类似数位dp的方法设计状态,用在值域大,且我们关心的性质相对简单(比如这里只是大小关系)

## slide.pptx

上面那个做不动啊,还是看看简单点的.

### CF1409F Subsetsequences of Length Two

> 给定 $s_n,t_2$ ,可以修改 $s$ 的最多 $k$ 个字符使得 $t$ 作为子序列在 $s$ 中出现次数最大.
> 
> $n\le 200$

$f_{i,j,k,l}$ 表示前 $i$ 个,修改 $j$ 个, $t_1$ , $t_2$ 的个数分别为 $k,l$ 的 $t$ 出现次数.

哦, $t_1,t_2$ 只需要记录一个.

### CF1404B Tree Tag

> 给定一棵树 $T=Tree(n)$ , $AB$ 初始时在 $a,b$ 两点,每次可以移动到距离不超过 $d_a,d_b$ 的点,交替移动 $A$ 先手,若 $A$ 能抓住 $B$ , $A$ 获胜.问谁赢.
> $n\le 10^5$ .

考虑因为无限步数,可以忽略前面过程,直接想什么时候必然抓住:

- $A$ 站在直径中点上, $B$ 死了
- $d_b\le 2d_a$ ,此时它不能跨过 $A$ ,那 $A$ 只要一步一步压缩即可.
- 一开始 $B$ 离 $A$ 太近

### CF1349C Orac and Game of Life

> 给定 $n\times m$ 01矩阵,每次若一个位置与它四连通的位置01相同就取反, $q$ 次询问 $i,j$ 在 $p$ 秒后是几.
> 
> $n,m\le 1000,t\le 10^5,p\le 10^18$

一个连通块总是同步的,可以缩起来.

如果一个格子某一时刻变了,那么它接着会一直变.

于是直接求每个格子最早的变化时间(容易发现非常早),bfs一遍转移.

### CF1338B Edge Weight Assignment

> 给定无根树 $Tree(n)$ ,为每条边赋值 $w>0$ ,使得任意两个叶子路径异或和为0,求最少最多的颜色数.
> 
> $n\le 10^5$

要求任意两个叶子中所有数出现偶数次,那最少的情况显然可以中间的全相等,在叶子上调整(再找两个数异或等于刚才的数一调就行了).

最多的情况,考虑一个点的所有叶子儿子到它的边要相同,除了这个之外都可以不同(初始化一个相同的解,然后在非常高的位置调整出一个1)

### CF1334D Minimum Euler Cycle

> 给定 $n$ 点的有向完全图(任意两点之间有两条边),求字典序最小的欧拉回路的第 $l$ 到第 $r$ 个点.
> 
> $n\le 10^5$

出发位置是最小值,以后每次走出边最小的就是策略了.

考虑这么做形成若干个环,对每个点统计这里出发的环的大小?不对.

降智,正确做法:完全图,所以实际上你可以任意走,要保证每条边正反各一次,直接构造:

$1\to 2\to 1\to 3\to \ldots 1\to n\to 2\to 3\to 2\ldots$

### CF1329A Dreamoon Likes Coloring

> 给定 $a_n$ ,进行 $m$ 次区间 $l_i,r_i$ 赋值,要求最后每个颜色出现至少一次,每个格子都有颜色. $l_i$ 给定, $r_i$ 不给定.
> 
> $n,m\le 10^5$

考虑直接把 $l$ 对应 $r$ 排序然后随便模拟.

### CF1322B Present

> 给定 $a_n$ ,求 $a$ 中任意两数对的和的异或和.
> 
> $n\le 4\times 10^5,a_i\le 10^7$

每一位分别考虑,要求一个数与其他所有数在第 $i$ 位上为 $1$ 的个数.两种情况:要么是直接加的,要么是进位出来的.

进位就是每个数只取前 $k-1$ 位,加起来大于 $2^k$ ,于是可以直接做了.

### CF1320C Battle for Azathoth

矩形加-最大矩形和,扫掉一维即可.

### CF1312E Array Shrinking

直接区间dp,注意若一个区间可以合并成单点,这个数是唯一的.

### CF1288D Minimax Problem

二分答案+变成一堆二进制数或起来全1+FMT.想不到吧,是可以直接枚举两个二进制数的(值域很小)

### CF1276B Two Fairs

$a,b$ 是割点,于是图分成三部分,答案是两边两部分的积.

哦, $a,b$ 不一定是割点,而是删掉它们之后, $u,v$ 是分别和 $u,v$ 相连的两部分.

### CF1213G Path Queries

离线排序从小到大,问连通块平方和之类的.

### CF1030E Vasya and Good Sequences

可以对每个数都把一整到最前面,一定不劣?不对,比如6,7,14这个样的,你会让它们下面的抵消,最后用6消掉上面的.

于是实际条件是,1的个数为偶数,并且最大的数的1的个数不超过总共个数的一半,发现不满足第二个限制的区间最长是 $w$ 的,于是暴力即可.

### CF959E Mahmoud and Ehab and the xor-MST

异或和为1的会连接任意 $2i,2i+1$ .

异或和为2的会连接差2的点.

发现加入异或和为 $2^i$ 的会合并前 $2^i$ 位,其他的不会合并.

于是答案就是

$$
\sum_i \lfloor \dfrac{n}{2^i*2} \rfloor 2^i
$$

### CF900D Unusual Sequences

都除以 $x$ ,问题变成互质序列加起来是 $\dfrac{y}{x}$ 的方案数.

没有互质可以直接隔板法是 $2^{y-1}$ .于是你就容斥, $g(x)$ 表示 $\gcd$ 为 $x$ 的因数的方案数, $f(x)$ 表示恰好为 $x$ 的方案数,莫反即可.

### CF859D Third Month Insanity

直接dp,一遍算在点 $u$ , $x$ 获胜的概率,一遍dp点 $u$ 子树内走到 $u$ 的是 $i$ 的情况下得分期望和.

### CF853C Boredom

简单容斥+二维数点

### CF1408E Avoid Rainbow Cycles

考虑把图简化,一个集合连一个团可以变为给每个集合建一个点,集合内的点向它连边.

此时原边权是现在两条边中间那个点的点权.

发现因为集合每个点多颜色是唯一的,这样做又不会形成同集合的环,所以只要有环就是rainbow.

然后开始想什么网络流建图可以约束没有环这一条件,哦,是最大生成树啊/hanx.

### CF1217E Sum Queries?

> 给你 $n$ 个数 $a_i$ .
> 对于一个子序列 $p$ ,定义 $s_p$ 为子序列中所有数的和.
> 定义一个子序列 $p$ 是好的,当且仅当 $s_p$ 用十进制表示时,对于 $\forall i$ ,都能在子序列 $p$ 中找到一个数 $x$ , 使得 $s_p$ 从低到高的第 $i$ 位与 $x$ 从低到高的第 $i$ 位相等.
> 你需要对序列 $a$ 做 $2$ 种操作:
> 1. 把 $a_i$ 修改成 $x$ .
> 2. 在 $a_l,a_{l+1}\cdots,a_r$ 构成的序列中,找一个 $s_p$ 最小的子序列 $p$ ,使得 $p$ 是坏的.你需要输出 $s_p$ .如果不存在,输出 $-1$ .
> $1\le n,m\le 10^5,1\le x,a_i<10^9$

考虑如果一个集合是坏只要有一位不全为0.于是随便维护.

### CF1215E Marbles

> 有 $n (n \le 4 * 10^5)$ 个珠子 , 第 $i$ 个珠子颜色是 $c_i (c_i \le 20)$ , 每次操作把**相邻**的两个珠子交换.现在要把相同颜色的珠子排列在相连的一段,问至少要多少次操作 .

给珠子钦定一个顺序之后就是排序了,排序是好做的.

那么设 $cost(a,b)$ 表示 $a$ 排在 $b$ 之后的代价,直接状压dp即可.

### CF1188C Array Beauty

> 定义一个序列 $b_1, \ldots, b_n$ 的美丽值为 $\min_{1 \leq i < j \leq n}\{\vert b_i-b_j\vert \}$ .给定一个长度为 $n$ 的序列 $a$ ,求 $a$ 的所有长度为 $k$ 的子序列的美丽值之和对 $998244353$ 取模的结果.
> $2 \leq k \leq n \leq 1000$ , $0 \leq a_i \leq 10^5$ .

先枚举一个美丽值,计算有多少个子集.

把 $a$ 排序.

$f_{i,j}$ 表示 $a$ 的前 $i$ 个里选 $j$ 个,美丽值大于当前值的方案数,复杂度 $n^2$ .或者确切的, $nk$

似乎过不了,但是你再想想,值域其实不是 $\max a_i$ ,而是 $\dfrac{\max a_i}{k - 1}$ !你就过了.

[think] 分析复杂度确切一点!

### CF1111E Tree

> 给定 $Tree(n)$ , $q$ 次询问给定 $k,m,r,a_k$ ,求将 $a_k$ 中点分为不超过 $m$ 组使得以 $r$ 为根的时候没有同组两点有祖先关系的方案数.膜 $10^9+7$
> 
> $n,q\le 10^5,m\le \min(k,300)$

直接虚树dp, $f_{i,j}$ 表示以 $i$ 的子树内分 $j$ 组的方案. 问题是合并两个子树信息的时候,可能有跨过子树的组,我们也不知道怎么办了(

枚举扫描线方向,子树dp相当于从儿子到祖先,考虑先祖先再儿子,于是想到dfs序排序,设 $f_{i,j}$ 表示前 $i$ 个点,分 $j$ 组,那么点 $i$ 的不能和它的祖先一组,可以挤进去或者新开一组,简单 $nk$ .

那么现在也不用虚树了,只要求有多少个祖先是关键点,简单单点加链求和.

但实际上手够硬也是可以的,考虑一开始组带着标号算,并且允许空组,此时两个子树合并的时候就是直接 $f_{i,j}$ 相乘,因为就相当于一共有这么多组,每次把一个子树的东西填进去,合并两个子树的时候就是直接对应相乘,容斥出非空盒子个数除掉阶乘即可.复杂度相同.

[think] 树上dp的扫描线方向,带标号简化问题+容斥.

### CF1097D Makoto and a Blackboard

> 给定 $n,k$ ,一共会进行 $k$ 次操作,每次操作会把 $n$ 等概率的变成 $n$ 的某个约数
> 求操作 $k$ 次后 $n$ 的期望是多少,答案对 $10^9+7$ 取模
> $1 \le n \le 10^{15},1 \le k \le 10^4$

显然 $n$ 只有 $\log n$ 段.考虑对这个计数,枚举一个 $n$ 的约数,再枚举 $n$ 到这个约数之间有多少段,隔板算方案数,但这是错误的,那个多少段根本没法数.

考虑把 $n$ 质因数分解,发现答案关于每个因子 $p^a$ 是独立的,此时就可以直接计算了.

[think] 计数要找独立!独立!

### CF1044D Deduction Queries

> 给定 $a_n$ 和 $q$ 次操作 $(1 \leq q \leq 2 \times 10^5)$ ,两种操作类型:
> `1,l,r,x`:表示已知 $a$ 的区间 $[l,r]$ 的异或和为 $x$ ,或者与已知矛盾忽略.
> `2,l,r`:表示询问 $a[l,r]$ 的异或和或判断不可知.
> 强制在线. $(0 \leq l,r,x \leq 2^{30})$

它确实张了一张并查集的脸啊!

考虑带权并查集,每个点维护到根的点的异或和,就行了.

### CF1043F Make It One

在数数题里.

### CF891C Envy

> 给出一个 $n$ 个点 $m$ 条边的无向图,每条边有边权,共 $Q$ 次询问,每次给出 $k_i$ 条边,问这些边能否同时在一棵最小生成树上.
> 
> $n,m,q,w,\sum k_i\le 5\times 10^5$

考虑Kru的过程,那么一条边权为 $w$ 的可以在最小生成树上当且仅当所有边权小于 $w$ 的都被插入之后 $w$ 两端点不连通.于是如果询问边权没有相同的可以直接可持久化并查集.如果有相同的元素按照任意顺序都是对的,于是按照任意顺序一个一个合并进去即可.

哦,实际上可以干掉可持久化,建操作树+撤销即可.

### CF875F Royal Questions

> 给定二分图,左边 $n$ 个点,右边 $m$ 个点,右边第 $i$ 个点连向左边第 $a_i$ , $b_i$ 个点,权值为 $w_i$ ,求权值最大的匹配.
> 
> $n,m\le 2\times 10^5,w_i\le 10^4$

将右边点看成边,于是一个连通块合法当且仅当是基环树或树.于是用最大生成树的做法去做.

### CF870E Points, Lines and Ready-made Titles

> 在一个平面上有 $n$ 个不同的点( $n$ 给出).而对于每一个点而言,你可以对它作一条垂直线,也可以作一条水平线,并且也可以不对它进行任何操作.(若有重合的线段则视为一条直线).请问你能得到多少种不同的图片呢?得出的答案对 $10^9+7$ 取模.

考虑点相互影响的关系,发现只有在同一水平竖直线才相互影响,于是每个点向四方向最近点连边,拆成若干个独立连通块.

考虑单独计算一个连通块,结论是,对于一个连通块,如果是树,答案为 $2^{A+B}-1$ ,否则是 $2^{A+B}$ .

考虑如果一个连通块是树,选择一个根,钦定其方向,然后让每个点和父亲的方向不相同,发现可以铺满除了根所在的所有行/列,于是只有全满的一种方案无法选择.如果一个连通块有环,此时选择环上一点做为根,就能全满.

### CF868F Yet Another Minimization Problem

显然四边形不等式.直接分治决策单调性.

### CF856B Similar Words

> [题目描述]
> 单词是由小写英文字母组成的非空串.
> 若一个单词去掉首字母后与另一个单词相同,则这两个单词相似.
> 现给定 $n$ 个单词(可能重复),请挑选尽量多的新单词组成集合 $T$ 并满足条件:
> 1. $T$ 中的新单词为原 $n$ 个单词的前缀(包含自身)
> 2. $T$ 中的新单词两两不相似.
> 求 $\max \vert T \vert$
> $\sum s_i\le 10^6$

考虑先求出所有前缀和每个前缀相似的字符串,可以用hash,把看每个前缀向删掉第一个字符之后得到的点连边,最后就是选最多的点使得没有两点有父子关系,直接树形dp.

### CF815C Karen and Supermarket

> 在回家的路上,凯伦决定到超市停下来买一些杂货. 她需要买很多东西,但因为她是学生,所以她的预算仍然很有限.
> 事实上,她只花了 $b$ 美元.
> 超市出售 $n$ 种商品.第 $i$ 件商品可以以 $c_i$ 美元的价格购买.当然,每件商品只能买一次.
> 最近,超市一直在努力促销.凯伦作为一个忠实的客户,收到了 $n$ 张优惠券.
> 如果 Karen 购买第 $i$ 件商品,她可以使用第 $i$ 张优惠券,将该商品的价格减少 $d_i$ 美元. 当然,不买对应的商品,优惠券不能使用.
> 然而,对于优惠券有一个规则.对于所有 $i\ge 2$ ,为了使用第 $i$ 张优惠券,凯伦必须也使用第 $x_i$ 张优惠券 (这可能意味着使用更多优惠券来满足需求.)
> 凯伦想知道.她能在不超过预算 $B$ 的情况下购买的最大商品数量是多少?
> $n\le 5000$

考虑 $x_i$ 形成的结构显然是森林,依赖是自顶向下的,设 $f_{u,i,0/1}$ 表示 $u$ 子树内是否使用优惠卷,此时用了 $i$ 元的最大收益,不行,换成买 $i$ 件物品的最少价格,转移就是背包.

### CF804D Expected diameter of a tree

> 给一片森林, $q$ 个询问,每个询问两个点,问从这两个点所在的连通块内各自均匀随机两个点,连接起来组成的新连通块,它的最远两点的距离的期望值是多少.
> $n,q\le 10^5$

先考虑一次询问.

一个点的贡献是 $b(\max_i dis_{u,i}+\dfrac{1}{2})$ ,其中 $b$ 为对面集合的大小,那就对每个集合维护这个即可.显然 $u$ 是两个直径之一.

不对,新直径可能是原来两个连通块的直径.

那么算两个集合的和小于 $x$ 的个数和总和,考虑分别排序,那么双指针就能算.或者在里面二分+前缀和.

现在多次询问,不会了.

好厉害的自然根号,考虑如果二分+前缀和,我们的询问只与小的那个大小有关,对于小于 $\sqrt n$ 的连通块算一次是 $\sqrt n$ ,对于大于 $\sqrt n$ 的只有 $\sqrt n$ 个大于它的,所以只要对大于 $\sqrt n$ 的记忆化复杂度就是1log.

[think] 总和为 $n$ 的集合, $\sum_a \sum_b \min(a,b)\le O(n\sqrt n)$

### CF600E Lomsat gelral

模板-线段树合并

### CF1379F2 Chess Strikes Back

> 给出一个 $2n\times 2m$ 的黑白交错棋盘,其中格子 $(1,1)$ 为白色.每次拿走或放回一个白格,问能否在剩下的白格中放入 $n\times m$ 个国王使得它们不互相攻击.
> 
> $n,m,q\le 2\times 10^5$

考虑有解条件,首先这个 $n\times m$ 和 $2n\times 2m$ 的关系不是没用的,考虑分成 $2\times 2$ 的块,于是任意一个块里恰有两个白格,一个国王.形成了一个类似2sat的限制,图上显然只有偶环.

没前途,2sat的模型并不适合性质,考虑一个矩形,发现要确定对角顶点的状态才唯一,于是发现没有一方格满足, $A$ 左上角不能放, $B$ 右下角不能放,且 $B$ 在 $A$ 的右下方,仅在此时中间的矩形不满足.(否则,一定在内部已经出现这样的格子对).

于是直接线段树维护两种最靠左上的 $A$ 和最靠右下的 $B$ 即可.

### CF1310C Au Pont Rouge

> 给出一个长度为 $n$ 的字符串 $S$ 以及整数 $m,k$ .
> 对于一个把 $S$ 分割成非空的 $m$ 段的一个方案,我们用这个方案中分割出的字典序最小的一个串代表这个分割方案.
> eg. $S=abaabb,m=3$ ,存在分割方案 $\{ab,aab,b\}$ ,则我们用字典序最小的 $aab$ 来代表这个分割方案.
> 现在把**所有分割方案对应的代表该方案的串**按字典序**从大到小**排序,求排序后的第 $k$ 个串.
> $n,m\le 1000,k\le 10^18$

困难的.

考虑二分字典序,现在求大于一个串 $t$ 的划分方案数.

显然为了满足 $m$ 和大于的条件,考虑记录 $f_{i,j}$ 表示 $[1,i]$ 划分 $j$ 段的方案数,那么此时有

$$
f_{i,j}=\sum f_{k,j-1},\ s.t.\ s[k+1,i]>t
$$

此时转移是 $n^3$ 的,因为我们找不到转移到性质--字典序更多取决于开头的 $k$ 而不是 $i$ ,所以同一个 $i$ 的决策看不到性质.

那么考虑倒着dp,记录最后一段 $[i,n]$ 的,此时转移的是一个后缀,就直接做了.

看看lyh的解法,考虑正着dp的时候一个 $j$ 可以转移到一个后缀的 $i$ ,于是用转移 $f_{i,j-1}\to f_{i,j}$ , $f_{i-1,j-1}\to f_{i,to_j}$ 做到这个转移.

[think] 可以感受到dp的自动机特性,lyh的解法相当于做了前缀优化建图.适用于前后缀(因为自动机不能记忆你是什么时候开始的区间).

### CF1270F Awesome Substrings

> 给定 $s,s_i\in \{0,1\}$ ,求它有多少个子串满足其长度为1个数的倍数.
> 
> $\vert s\vert \le 2\times 10^5$

倍数一般与某些自然根号,对数性质有关.

考虑一个经典做法是对于一个固定倍数 $k$ ,把 $0$ 当成 $-1$ ,1当成 $k$ ,有解就是区间和为0,可以扫一遍得答案.那么此时想到根号分治,这个用于 $k<\sqrt n$ .

对于 $k>\sqrt n$ ,则 $1$ 的个数要小于根号,于是枚举小于根号的1的个数就行了.

### CF1270H Number of Components

> 给一个长度为 $n$ 的数组 $a$ , $a$ 中的元素两两不同.
> 对于每个数对 $(i,j)(i<j)$ ,若 $a_i<a_j$ ,则让 $i$ 向 $j$ 连一条边.求图中连通块个数.
> 支持 $q$ 次修改数组某个位置的值,每次修改后输出图中连通块个数.
> $n,q\le 5\times 10^5,1\le a_i\le 10^6$ ,保证任意时刻数组中元素两两不同.

首先考虑连通块的性质,发现若 $i,j(i<j)$ 连通,则任意 $k\in [i,j]$ 都连通,于是一个连通块一定是一个区间.

于是问题变成有多少个 $i$ 满足 $\min_{j\in [1,i] a_j>\max_{j\in [i+1,n]} a_j$

考虑一个折线模型,发现 $i$ 满足条件代表 $y=a_i-\dfrac{1}{2}$ 这条线与整个折现只有一个交点,发现我们成功的把修改时信息的影响变得局部--折现只与它左右两边的元素有关,于是用值域线段树维护每个位置被折现覆盖了多少次的最小值何最小值个数(或者, $y=x$ 与多少条折现经过),修改就是区间加了.

### CF1260F Colored Tree

> 给定一棵树,每个节点有一个颜色 $h$ , $h_i$ 为 $[L_i,R_i]$ 内的一个整数.
> 现在,对于所有 $\prod (R_i-L_i+1)$ 种不同的染色方案,求出下列式子之和:
> $$\sum_{h_i=h_j,1\leq i<j\leq n}dis(i,j)$$
> $n\leq 10^5,1\leq L_i\leq R_i\leq 10^5$ ,答案对1e9+7取模.

能不能拆成边的贡献啊...一条边的贡献为每种颜色 所有方案下在两边的个数乘起来 之和,然后呢?

那再考虑对每个颜色分别求,这个好像可以虚树实现.

于是问题变成求一个颜色在一个子树内的所有出现方案的出现点数之和.

考虑写成 $a+x$ 卷起来,要求系数和次数的点积.那是不是求导把次数移下来就好了.所以是问在1处的导数.

这个是可以做的, $(\prod_i a_i)'=\sum_i (a_i'\prod_{j\ne i}a_j)$ ,于是就是在这个区间里选一个的贡献是导数,剩下的是原来的,这个问题是可合并的,或者从ddp上想.于是可以单点修改/查子树.

设 $R_i-L_i=l_i$ .

诶好像建虚树是错的啊...复杂度假了...但上面那部分是对的,再想想,考虑扫描线颜色维(这里颜色实际是有大小关系的),设每个边两边的这种颜色的所有方案的出现点数之和分别是 $A,B$ ,那么 $A\times B$ 就是这条边的贡献,那么现在扫着扫着要支持添加一个点或删除一个点,发现按照刚才的做法求导之后 $A=\sum_i \prod_{j\ne i}l_j$ ,就要求 $(\sum_i \prod_{j\ne i} l_j)\times (\sum_k \prod_{l\ne k}l_k)$ ,发现添加一项不是线性变换,但可以直接两边都除以 $\prod_i l_i$ ,这个对所有点是相同的提出来,就成了 $(\sum_i \dfrac{1}{l_i})(\sum_j \dfrac{1}{l_j})$ ,就是线性变换了.

然后写成矩阵,发现行列式恒为1,于是是可逆的,就支持加点删点了,用线段树维护dfs序,复杂度1log.

这个题还有其他做法啊:好像大家都是考虑的点对贡献而不是边.

于是点对 $u,v$ 贡献就是

$$
dis(u,v)\times \dfrac{all}{l_ul_v}
$$

然后依旧扫描线,这次用点分树维护跨过根的即可.


### CF1254D Tree Queries

> 给定一棵 $N$ 个节点的树,有 $Q$ 次操作
> 
> $1\space v\space d$ 给定一个点 $v$ 和一个权值 $d$ ,等概率地选择一个点 $r$ ,对每一个点 $u$ ,若 $v$ 在 $u$ 到 $r$ 的路径上,则 $u$ 的权值加上 $d$ (权值一开始为 $0$ )  
> 
> $2\space v$  查询 $v$ 的权值期望,对 $998244353$ 取模
> $1\leqslant N,Q \leqslant 150000$

固定 $r$ , $v$ 决定了加到子树的哪一边.好像很不可做.

固定 $u,v$ 考虑被加了几次,显然是 $dis(u,v)$ ,问题就成了每次给 $u$ 加上 $dis(u,v)*d$ ,单点询问.

那么这个很经典啊,点分树+线段树.等等,看成给 $r$ 到 $v$ 的路径上了加.

再看看,是给 $v$ 子树外的点加子树大小次,自己加 $nd$ 次,关键是子树内的点,每个被加了子树大小减自己所在的子树的大小.

最后这块不好办,考虑树上差分,并且每个位置维护子树被加了几次,就是要给 $v$ 子树加1,每个儿子这个次数减1,上科技的做法是毛毛虫剖分///kx

考虑一个阳间做法,树剖,每次修改的时候给重儿子区间加,对于轻儿子,跳它祖先上每一条轻边算贡献即可.

### CF1223F Stack Exterminable Arrays

收录在dp里.

### CF1220F Gardener Alex

> 给定排列 $p_n$ ,可以进行 $k$ 次向左循环移位,问大根笛卡尔树深度的最小值以及循环移位次数
> 
> $n\le 2\times 10^5$

考虑复制一倍,然后从上往下扫描线,每次会碰到若干个位置,这些位置细分了已有的线段,若位置 $x$ 切了一刀,不会算贡献.

考虑动态的做:每次从左边拿一个到右边叫 $u$ ,则原来 $u$ 的右儿子挂到 $u$ 左边第一个大于它的,新的父亲是它左边第一个大于它的点 $v$ ,小于 $v$ 的没有影响, $[v,u]$ 之间的点挂到了 $u$ 的左子树且结构不变.现在可以LCT+线段树1log.

考虑不LCT,而是变成每个位置维护其深度,是不是就做完了.

### CF1188D Make Equal

> 给出 $n$ 个数字 $a_1 , a_2 , \ldots , a_n$ ,每次操作可以给其中一个数加上 $2$ 的非负整数次幂.求最少的操作次数,使得这 $n$ 个数相等.
> $n\le 10^5,a_i\le 10^17$

从低位往高考虑,dp让它们全相等的最小代价,想dp发现要记录每个位置是否往上进位...就死了.

考虑不能直接dp,因为进不进位是乱的,因为只能加不能减,发现最优策略一定是,先操作最大值,然后把所有数操作到同一个数,设$ma=\max_i a_i$,则要最小化$\sum_i \operatorname{popcount}(ma+x-a_i)$,所以设$b_i=ma-a_i$,就是让它们加同一个$x$了.

考虑此时再dp,仍然要进位,但因为都是加上同一个数,所以进位到第$k+1$位的只能是前$k$位最大的那些数,,设$f_{i,j}$表示前$i$位,进位的是最大的$j$个,就可以了.

[conclusion] 加同一个数时进位的一定是一个后缀,同CF1322B.
[think] 是构造了满足某条件(这里的进位)的一个偏序关系去压缩状态.

### CF1142D Foreigner

> 给定数字串$s$,求其中有多少子串表示的数是特殊的.定义特殊的数是$[1,9]$的数,或者对于 $k= \lfloor \dfrac{x}{10} \rfloor$,$k$是第$i$个特殊的数,则要求$x\bmod 10<k\bmod 11$.
> 
> $n\le 10^5$

考虑在序列上扫,维护以$i$结尾的特殊的数,那么显然它们必须在第$i-1$位结尾时也特殊,并且第$i$位要小于它们的编号,发现我们并不需要维护每一个特殊的数--编号膜11相同的对后面贡献相同,所以$f_{i,j}$表示以第$i$位结尾,编号膜11余$j$的数的个数,我们希望知道$j$这一维怎么转移.

发现我们需要算编号为$a$的数往后加上数$b$(这个操作起名拓展)后的新编号,考虑由$c<a$拓展得到的数一定都小于$a$拓展得到的,于是新编号就是

$$
9+\sum_{j\in [1,k-1]} (i\bmod 11)+c+1
$$

意思是算上不是被拓展的9个数,以及比$k$小的拓展的所有数.发现$i$每11个加的数是一样的(是$0+1+2+\ldots+10=55\equiv 0 \pmod 11$),于是我们确实可以像上面一样只记录余数转移了.

### CF1129D Isolation

> 给出一个长度为 $n$ 的序列，把它划分成若干段，使得每一段中出现过**恰好**一次的元素个数 $\le k$，求方案数对 $998244353$ 取模后的结果。
> $n\le 10^5$

设$f_i$表示前$i$个的方案数,转移就是枚举最后一段断在哪,是$n^2$的.

于是优化这个,考虑维护$cnt_j$表示区间$[j,i]$这一段恰好出现一次的数的个数,那么现在加入一个位置$i+1$后,发现若设最大的$k$满足$a_k=a_{i+}$,则$[k,i+1]$的$cnt$加$1$,$[1,k]$的$cnt$减$1$,然后求$cnt$大于一个数的$f$的和,可以时间分块+根号平衡,或者直接序列分块.

### CF1098D Eels

> 小V有一个水缸和一堆鱼，水缸初始是空的，小V接下来会向水缸内加入一些鱼，同时也可能将已加入的鱼捞出来。
> 水缸里的鱼会相互攻击，直到只有一条鱼为止。也就是说如果有$n$条鱼，则会发生$n-1$次攻击。 如果一条鱼的重量为$A$,另一条鱼重量为$B$，如果$A\le B$，则$B$鱼会吃掉$A$鱼，然后$B$鱼体重变为$A+B$。
> 对于一场攻击来说，如果一条鱼的重量为$A$,另一条鱼重量为$B$，如果$A,B$满足条件 ：$A\le B$ 而且 $B\le 2A$ 那么我们定义这场攻击是危险的。
> 现在小V会有$q$次操作，包括加入一条体重为$x$的鱼，或捞出一条水缸内的、体重为$x$的鱼。
> 小V想知道，在每次操作后，水缸内能发生的最多的危险攻击次数是多少。
> 
> $q\le 500000$

考虑一次询问怎么做?(好像不会啊...)

首先发现能现在危险的一定可以不拖到以后,所以你先尽可能合并危险的.

直到现在任意两个鱼打都不是危险的,发现此时最多有$\log v$条.

发现不会.

考虑猜一个更厉害的结论,一定每次拿最小的两个合并.

那么如果此时最小的$a,b$是危险的你就直接合并,现在发现$a<2b$,那么假设此时合并$bc,c>b$是危险的,发现首先$a$和后面的合并永远不是危险的了,并且把$a$先合并到$b$上一定不劣,就证完了.

于是考虑维护一个有序的数字,答案就是$a_i\le s_{i-1}$的$i$个数,其中$s$为前缀和.

考虑不合法的合并只有$\log V$次,那么开个平衡树,每个位置维护当前值减前缀和,就要做到插入,后缀加,查询大于0的数的个数,很遗憾这个做不了,但是可以查区间最小值是简单的,因为只有$\log V$次每次往后跳复杂度是对的(finger search 1log!)

看看其他人都高妙做法,根据权值划分段,$[2^i,2^{i+1})$作为一段,每一段只有最小的可能不是危险的,直接维护和就做完了.

### CF1044F DFS

> 给定$T=Tree(n),G=Graph(n)=T$,$q$次每次在$G$中加一条边或删一条边,不会删$T$中的边,问$G$中有几个点满足从这里开始dfs有可能得到dfs树为$T$.
> 
> $n,q\le 2\times 10^5$

考虑一次怎么做.

那么要求,若点$u$在$T$上是叶子,你在图上走到$u$的时候它的相邻点都走过了.然后发现除了$u$的其他$fa_u$的相邻点应该都走过了这样的.

这样会在树上建一个DAG,边数是线性的,问一个点能不能走一个路满足这个先后关系,好像完全不可做.

[think] 考虑单个操作的简单影响而不是全体操作复杂的限制.

发现对于一条非树边$u\to v$,相当于让链$u$,$v$之间的点以及它们的子树全不行了,发现也就是只有$u,v$和链不同向的子树满足条件,就直接区间加全局最小值个数.

### CF917C Pollywog

> $n$个位置编号$1\ldots n$,$x$只青蛙,开始在最左侧的$x$个位置上,每一秒最左侧的青蛙向右跳,位于石头$i$的青蛙可以跳跃到$[i+1,i+k]$,体力花费为$c_1\ldots c_k$,不能有两个青蛙在同一位置.
> 
> 另有$q$个石头是特殊的,若一个青蛙是特殊的,则会额外花费$p$的体力.
> 
> 求它们跳到最右边的$x$个石头的最小代价.
> 
> $x\le k\le 8,n\le 10^{18},q\le \min(25,n-x)$

状压dp.

压缩$f_{i,S}$表示最靠前的青蛙在$i$,其中$[i-7,i]$是否有青蛙的状态是$S$.

然后想到矩阵快速幂,矩阵大小256*256,那么预处理$2^k$次转移的矩阵,特殊点分成若干段,每次用矩阵乘向量优化?

然而发现预处理已经上天了,矩阵太慢了.

但倍增的思路一定是对的,考虑设$g_{i,S_1,S_2}$表示$S_1$转移$i$次到$S_2$的代价,发现可以倍增$g$,转移$f$,但这个和矩阵显然本质相同啊,复杂度也没变.

不会了,看lyh题解,就是这个倍增dp,只能用常数小解释了.///hanx

不过其实是可以优化到能过的范围的,考虑实际上$\vert S\vert=n$,所以矩阵大小不是$2^k$而是$\binom{n}{k}$,最大是$\binom{8}{4}=70$!.就无敌了.

~~刷~~糊完了lyh的一个课件!///tiao///tiao///tiao