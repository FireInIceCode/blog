---
title:  LYHDP选做
subtitle: 总有一天...
layout: post
show: false
istop: false
tags: 
- 咕咕
---

# LYHDP

数数题默认膜998244353.

## CF1408G Clusterization Counting

> 给定 $n$ 点带权无向联通图,求把其划分成 $k$ 个不交的组的方案,满足任意 $s,f,x,y$ 中若 $s,f,x$ 同组, $y$ 与 $x$ 不同组,则 $w_{x,y}>w_{s,f}$
> 
> 对 $1\ldots n$ 的每个 $k$ 输出答案.
> 
> $n\le 1500$

考虑这个限制的实际含义是组内边大于组间边~~(然后用形式化题意恶心人)~~.

于是考虑直接按边权递增加边,相同边权一起加,那么每个组必然是出现过的连通块.

考虑连通块的总个数,发现若形成新的连通块必然要加入新点和已有合并,只有 $O(n)$ 个.

于是把 $O(n)$ 个连通块的包含关系建树,那么问题就成了在树上选 $k$ 个没有祖先关系的点的方案数.

考虑dp, $f_{u,i}$ 表示 $u$ 子树内选了 $k$ 个即可.

[think] 把限制变成更实际意义的形式理解
[think] 不交的关系在包含关系的树上(父亲代表的集合包含儿子)表示为树上没有祖先关系

## CF1383E Strange Operation

> 有一个长度为 $n$ 的 $01$ 串 $s$ ,可以对该串进行若干次操作,每次操作可以将两个相邻的数字合并为两者的最大值(操作之后字符串长度减少 $1$ ).问操作后有多少种可能的字符串.
> 
> $n \le 10^6$

考虑合并操作实质是让一个连续0段或1段缩短一个,但1段不会消失,0段有可能消失.

那么考虑判定串$t$可以被$s$得到,从头开始扫,如果当前0段长度大于$s$的0段,那么认为$s$的这个段被消没了接着往下匹配,如果当前1段大于$s$的1段,那么认为下一个0段被消没了打通到下一个,这么贪心的匹配.

那么考虑dp方案,用dpofdp的思想,内层状态只需要记录$t$是0/1段,长多少和$s$的一段长多少,显然是过不了的.

毫无用处.

看题解,它用$a_i$表示$s$第$i$个1和第$i+1$个1之间0的个数,认为可以得到叫包含,则设$f_i$表示$a_1\ldots a_i$能够,而更小的前缀无法包含的序列个数.假设能包含的序列最后一项是$x$,那$x$肯定与$a_i$对应,考虑如果上一项对应$a_j$,那么$i,j$之间的$a_k$都要小于$x$不然就能被更短的包含了.于是要找到最大的$a_k\ge x$的$k$,$x$的方案就直接区间和.复杂度线性.

然后再处理点边界,如果$s$只有0是简单的,并且假设$s$最后最前分别有$x,y$个0,那么可以把它们剥去,最后乘上$(x+1)(y+1)$,用两边都是1的做.

[think] 感觉就是,当我们知道如何数数的时候,可以思考一个状态数$O(1)$的判定,把它塞到dp里.

## CF1372E Omkar and Last Floor

> 给一个$n\times m$的网格,每一行被分成若干块,要把格子里填满0/1,每个块内仅有一个1,最大化$\sum {q_i}^2$,其中$q_i$为第$i$咧的元素和.
> 
> $n,m\le 100$

考虑一定会让最多的列填满.

那么至少让一列填满.填满的这一列可以把它分成两半,每一半结论相同.

那么区间dp,设$f_{l,r}$表示$[l,r]$完整包含的块的答案,那么枚举一个满的列分成两边就行了.注意只要完整包含是因为如果没有完整包含一定在其他地方有了1.

## CF1366G Construct the String

> 给定一个包含小写字母和$\texttt{.}$串$s$,$\texttt{.}$表示backspace,按顺序按下这些按键,空串再删会崩溃,求删除最少的字符使得结果为$t$且不崩溃.
> 
> $\vert t\vert\le \vert s\vert \le 10^4$

$f_{i,j}$表示$s$的前$i$个,匹配$t$的前$j$个都最小代价.能转移吗?

如果当前字符是 $\texttt{.}$,不会转移.

设$f_{i,j}$表示前$i$个删$j$个得到$t$的最长长度,能转移吗?

如果当前字符是 $\texttt{.}$,也不会转移.

哦第一个是可以转移的啊.考虑如果一个区间如果执行完是空的,那么就可以从这个区间前转移,预处理每个位置从哪里转移过来是简单的.

[think] 考虑dp的转移的时候思维还是太局限,**要枚举尝试从多个维度上跳跃的转移过来的可能性**.

## CF1342F Make It Ascending

> 给一个长度为$n$的序列$a$,你可以若干次选择$i\ne j$,让$a_j:=a_j+a_i$并删除$a_i$,用尽可能的操作将序列变成严格增.
> 
> $n\le 15$

$n\le 15$,但没有那么高妙,只要猜状态.

考虑题目是要你选若干个集合,和递增,且每个集合选择其中的一个元素的位置递增,且选的集合尽量多.

那你就设$f_{S,i,j}$已经选了集合$S$,已经选了$i$个集合,然后最后一个集合的元素的位置是$j$的情况下最后一个集合的和的最小值.

状态好像挺自然?小于20的dp要使劲设!

## CF1326F2 Wise Men (Hard Version)

> 给定一个$n$个点的无向图,对于一个排列$p_n$,对应一个$01$序列$a_{n-1}$,其中$a_i$表示$p_i$和$p_{i+1}$之间是否有边,给出图,求对于每个01序列对应多少排列.
> 
> $n\le 18$

居然是容斥题.

考虑限制是第$i$位为1或无所谓,求方案数,那么只要容斥就能得到答案了.把这个得到的用FMT可以得到答案.

那么现在一个限制串$s$,$s_i$为1表示这一位必须为1,否则任意,那么其中的0将1分成若干段,每一段内必须有边,段间随便走.

那么每一段的大小加一(长$k$的段决定排列中长$k+1$的区间中路径必须都走有边的)构成的可重集相同的$s$答案相同.原因是考虑:段间不做要求所以两个段可以任意互换.

于是对每个可重集求答案.因为可重集总和是$n$,所以只有18的划分数大概不到400种情况.

[?] 对每个可重集求答案,可以直接选取可重集中的任意一个限制串求,那么设$f_{S,i}$表示走过集合$S$,当前走到$i$的方案数去dp.

奇怪,大家的做法好像都是处理长度为$i$,走过$S$中点的方案数$g_{i,S}$,然后把对应$g_i$拿出来跑卷积.

![picture 2](/img/2022-10-21-20-05-27-image.png)  

## CF1290F Making Shapes

> 给定$n$个向量,你可以把它们接起来走回原点得到多边形,求这个多边形是凸的且可以被$m\times m$的矩形框住的方案数.不同位置的凸多边形算不同的.
> 
> $n\le 5,m\le 10^9,x_i,y_i\in [-4,4]$

考虑实际上多边形的形状仅取决于每种向量的个数,因为凸多边形意味着我们对向量极角排序.

于是问题变成确定每组向量个数使得它们两个方向上和为0.设个数分别是$c_1,c_2,\ldots,c_n$

这个东西很难做,因为它们的数量实在太大.考虑**逐位确定个数**,设$f_{i,0/1,0/1,0/1,0/1,0/1,0/1}$表示$x,y$与$m$在前$i$位的大小关系,进位和正负,每次枚举$n$个$c$在下一位是0/1的$2^n$种情况.

[think] 逐位确定个数,用类似数位dp的方法设计状态,用在值域大,且我们关心的性质相对简单(比如这里只是大小关系)

