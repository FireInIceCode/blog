---
title: 南外集训
subtitle: 
layout: post
show: true
top: false
tags: 
- 日志
password: usbombnlm
---

## NOIP模拟赛43
todo
### A. 括号	
### B. 学校	
### C. 运算	
### D. 乘积

## NOIP模拟赛44

### A. K 近查询

> 给定序列$a_n$,对每个$k\le lim$求$j$使得$j$是$j < i,a_j\ge a_i$中第$k$大的.
> 
> $n\le 10^7,lim=1$或$n\le 3\times 10^6,lim=5$

简单题,对$10^7$的部分直接单调栈,对$lim=5$的部分建出链表,然后从小到大删元素并统计答案.

### B. 树上流水

> 给一棵$n$个点的外向树,根有无限水,边有容量限制,每秒可以把水延边推动,求最少几秒使得叶子处总水量至少为$K$.
> $K\le 10^9$,$n\le 1000$

容易想到dp,设$f_{u,i}$表示点$u$发出$fw_u=w_{fa_u\to u}$的流量在$i$秒后最多有多少到叶子,转移大概是$f_{u,i}=\min (\sum f_{v,i},fw_u)$,然后求出$1$的就可以算答案了.

然而赛时一开始没看到$n\le 1000$(它写$\sum n\le 5\times 10^4$),所以可以写线段树合并加速转移.或者动态dp每次删最底下的东西,或者可并堆,都能做到单log.

当然也容易想到贪心,因为你一定优先流深度低的叶子.

### C. 逆序对

> 给定一长为 $2^n$ 的序列 $p_1, p_2, ..., p_{2^n}$, $m$ 次操作，每次操作给出三个整数 $q_i$, $l_i$, $r_i$，然后对序列作如下变换：
> 
> - 将序列分为 $2^{q_i}$ 个大小为 $2^{n-q_i}$ 的块。    
> - 选择第 $l_i$ 到第 $r_i$ 个块。 
> 
> 每次操作后，输出整个序列的逆序对数。

直接线段树维护就行了.建线段树后,每个点记录$w_x$为左儿子对右儿子的逆序对数,发现翻转这个节点(交换左右子树,子树内不变)只影响本节点的$w$且可以预处理,而题目所要求的翻转一个区间就是翻转区间对应节点的所有子树.于是要打懒标记,记录$s_x$表示$x$子树中集合$s$中的层都要翻转,$c_{x,i}$表示$x$子树中深度为$i$的那层节点翻转后的$w$减去翻转前的$w$就做完了就能合并标记和处理变化了.复杂度2log.

### D. 净土裁断

> 在一棵$n$点树上随机游走,在点$u$有$p_u$概率停留$1s$,有$1-p_u$概率等概率走到相邻一点,走到$1$停止,求每个点走到$1$的步数的$k$次方的期望.
> 
> $n\le 10^5,k\le 10^3$

先考虑$k=1$怎么做,那么

$$
f_u=p_u(f_u+1)+(1-p_u)\sum_{u\to v}(f_v+1)
$$

然后这个有后效性,学到一个树上高消:依赖关系成树之后叶子的式子可以写成$f_u=a_uf_{fa}+b_u$,然后把这个式子带入父亲的式子就消掉自己,于是父亲最后也表示成关于爷爷的一次函数,以此类推,最后推到根,再用根的值算出整棵树的dp值.

遇到$k$次方常见套路是EGF和斯特林数.

斯特林数,则$x^k=\sum_{i=0} \binom{n}{i}{k\brace i}i!$,于是要算$\sum \binom{l}{i}$,于是

$$
f_{u,k}=p_u(f_{u,k}+f_{u,k-1})+(1-p_u)\sum_{u\to v}(f_{v,k}+f_{v,k-1})
$$

于是仍然套刚才的树上高消,复杂度$nk+k^2$

假设我们一开始选择EGF,则设$F_u(x)$表示$\sum_{l\in S} p_le^{xl}$,其中$S$是所有方案下到根步数的多重集,那么列出$F_u(x)=p_ue^xF_u(x)+\sum_{u\to v}(1-p_u)e^xF_v(x),F(1)=1$并仍然套用刚才树上高消的转移,这个转移不动因为卷$e^x$复杂度是$k\log k$的,考虑换元$t=e^x$则$F_u(t)=p_utF_u(t)+\sum_{u\to v}(1-p_u)tF_v(t)$,此时卷上单个$t$复杂度就$O(k)$了.



## USACO 2018 铂金

> A. Balance Beam

想到dp$dp_i=\max (f_i,\dfrac{1}{2}(dp_{i-1}+dp_{i+1}))$,但这个转移不了.

考虑一些点$dp_i=f_i$,那么这些点就把序列分成若干段,每一段内的点的dp值就由两边的断点决定.而发现走到左右断点中的哪一个的概率是能求的:和距离成正比.

然后最厉害的地方在于,考虑把它们以$i$为横坐标,$f$为纵坐标画到平面上,则中间的点就是断点连线在这个横坐标的值.现在把$i,v_i$画到平面上,选择若干个点使得对应横坐标最大,发现这是凸包.于是最后只要求个凸包就做完了.

[think] 想出一个最优策略
[conclusion] 在$[1,l]$的线段上,每步随机走到$-1+1$的位置,点$x$从$0$出来的概率是$\dfrac{x}{l+1}$

> B. Sort It Out

集合外的点相对顺序不变,于是集合外的点必然是升序的,在此基础上发现集合内的每个点都会到正确的位置上.那么剩下的是一个LIS,发现若两个LIS的字典序关系和它们的补的大小关系相反(考虑其第一个不相同的元素前都相同,第一个不相同的元素$B$大则补中$B$缺一个大的$A$缺一个小的).于是求第k$大LIS,设$f_i,g_i$表示以$i$结尾的$LIS$长度和个数,$g$的转移一定是$f_j=f_i-1$的一个后缀转移过来,如果对每种$f$的值开一棵线段树,那么就是区间查,最后求第$k$大也就是在线段树上面二分.复杂度单log.好吧实际上求$g$可以直接维护最大值对应元素之和,二分也可以直接二分,但这样是先确定尾不断往头走,所以应该翻过来找下降序列.

[think] 寻找不变性,排除一定不合法的情况分析充分性.这里先要求集合外升序,而集合外不升序的情况下集合内的点最终目标没有好的性质.

> C. The Cow Gathering

容易想到建成根向有根树,把限制边连上就是问每个点开始有没有环.

发现对于限制$u\to v$,所有以$v$为根的$u$的子树都不能当根了.于是ban掉$O(1)$个dfs区间.

[think] 考虑每个限制的贡献

> D. Lifeguards

看到$k=100$直接dp,显然有包含关系可以全杀了,然后按$r$排序,$f_{i,j}$表示前$i$个区间删$j$个的最大值转移不了,不知道转移过来时那里有没有删,那么钦点$i$必选,考虑前面一段没有选,然后从$f_{k,j-1}$转移来,此时若$r_k>l_i$则贡献就是$f_{i,j}=f_{k,j-(i-k+1)}+(r_i-r_k)$,否则是 $f_{i,j}=f_{k,j-{i-k+1}}+(r_i-l_i+1)$,对$k$的限制就是前后缀,发现其实是要知道$f_{k,k+(j-i-1)}$,对每个差维护单调队列即可$O(1)$转移.

[think] 钦点状态加强性质帮助转移,困难是不知道最后一个被删的是谁那可以钦点成自己

> E. Cow at Large

Bessie通过一个点的条件是这个点最近的叶子到它的距离小于根到这个点的距离,所有不能通过的点中父亲能通过的就是你会用来堵死bessie的点(农民会走到这些位置).

考虑怎么不依赖父亲,考虑此时先拿出所有Bessie不能通过的点,容斥出答案,我们值希望让每个子树的和为$1$即可,于是叶子贡献$1$,每个点贡献负的度数减$1$即可.

于是统计答案,要对每个点$u$求所有$dis_{u,v}>p_v$的$v$的权值和,点分治就可以了.

[think] 容斥点权使得子树和为$1$相当于最上层点个数

> F. Sprinklers

显然水和废料覆盖的分别是一个阶梯状,要数两个阶梯状的交里放下几个矩形.考虑直接扫描线,因为值域$O(n)$,维护纵向的扫描线上每个$y$坐标在扫描线有多长一段合法的,每次移动区间加,发现答案贡献要再维护下标和值的乘积就做完了.

> G. Out of Sorts

考虑每个位置什么时候出现分隔点,因为每次冒泡都让右边比$i$小的元素向左移动一格,于是可以求出冒泡次数.于是每个位置的贡献就是两边分隔出现时间中的较大值.于是就结束了.

不会做就拆贡献!

> H. Train Tracking

咕咕

> I. Disruption

这不是模板题吗!直接并查集就能做到$n\alpha (n)$

## NOIP2023模拟赛45

### A. 树上删边

> 有一棵$n$个结点的树，每个结点有一个权值，删除一条边的费用为该边连接子树中结点权值最大值之和。问以任意顺序删除树中所有边的最小花费。
> 
> $n\le 10^5$

容易发现,应该按照边的两个端点中大的一个排序然后依次删除.然后为了维护这个可以倒过来加边并查集.

### B. 欧几里得	

> 定于
> $$R(a,b)=\begin{cases}R(b,a)\ if\ a<b\\R(\lfloor\dfrac{a}{b}\rfloor,b)\ if\ 1<b\le a\\a\ if\ b=1\end{cases}$$
> 给定$g,h$,求任意一组$a,b\le 10^{18},R(a,b)=\gcd(a,b)$

考虑$\gcd$的限制是精确的,而$R$每次是给一个范围,于是想到从$R(1,h)$往回倒退$a,b$的范围,往前一组肯定是$R(h,x),x\in [h^2,2h^2)$,于是发现你可以不断对 $[h^2,2h^2)$ 乘一个$h$扩大它的范围,然后让我们的答案分别是$ag,bg(a>b)$,那么经过一次递归之后变成$R(\dfrac{a}{b},bg)$,于是只要能找到 $bg\in [h^k,2h^k)$,则能算出$ag=hb+i(i\in (0,b))$使得$gcd(ag,bg)=g$,容易发现$gcd(ag,bg)=gcd(i,bg)$,于是直接让$i=(b-1)g$即可.赛时没细想最后一步直接写了个$0,b$范围内随也过了.

### C. 没有上司的涨薪舞会

> 一个公司有 $n$ 名员工，$1$没有直接上司，其余员工都有一个直接上司。这样的直接上司关系构成以 $1$ 为根的有根树。已知这颗树。一个员工的直接下属，指以他为直接上司的所有员> 工。一个员工的下属，指他子树内除他以外的所有员工。
> 
> 这些员工都十分渴望涨薪，所以有些人会要求涨薪。记 $s_i$ 为第 $i$ 个员工是否要求涨薪，“是”为 $1$，“否”为 $0$。不知道序列 $s$。
> 
> 现在所有员工都被邀请去了一个舞会。但是并不是所有人都十分想去，而且他们是否参加会以自己的直接下属参加情况为参考。每个人 $u$ 都会等待自己所有下属都决定完，然后：
> 
> 若不存在直接下属决定参加舞会，则以 $p_u$ 的概率参加舞会；
> 
> 否则，一定不参加舞会。
> 
> 已知序列 $p$。
> 
> 这个公司里，每位员工都有权力和义务给自己的下属涨薪/降薪。在这个舞会上，每位参加舞会的员工 $u$ 会对每个要求涨薪并且参加舞会的下属都涨薪 $a_u$。这个值可以是负的，因为有些人心情很差，专门给要求涨薪的人降薪。已知序列$a$。
> 
> 求使公司所有员工涨薪量之和期望最大的序列 $s$。不用输出序列 $s$，只用输出期望的大小。保证答案在 $10^{11}$ 以内。
> 

期望的线性性说可以对每个点分别求祖先到它的期望.此时你可以智慧的直接设$f_{u,0/1}$表示$u$一定来或不来时祖先造成的贡献去dp,或者直接看成每次修改$a_u$,上一个矩阵优化的静态动态dp,只要维护到根的矩阵连乘积.

### D. 最大子段和

> 给定$\{a_n\}$,每次可以选择$p$让$a_p:=a_p-1$,定义$g(i)$表示操作$i$次后最大子段和的最小值,$q$次求$\sum_{i=l}^r g(i) \pmod {10^9+7}$
>
> $l,r\le 10^{15},n,q\le 5\times 10^5$

看到这个询问可以直接猜答案是$O(n)$段一次函数的区间和.但问题是一个子段和可能随着减小突然裂开成两个.

考虑二分答案转为求让答案减少到$V$需要操作多少次,,线性规划形式为

$$
\min_c \sum_i x_i\\
s.t.\forall l,r\ \sum_{i=l}^r a_i-x_i\le V\\
x_i\ge 0
$$
标准型
$$
\min 1\cdot x\\
Ax\ge c\\
x\ge 0
$$
$A$是$\dfrac{n(n-1)}{2}\times n$的矩阵,每行对应一个区间,这一行中属于这个区间的位置是$1$其他是$0$,$x$是长$\dfrac{n(n-1)}{2}$的数组每个位置为$sum-V$.对偶之后变成

$$
\max c\cdot y\\
A^Ty\ge 1\\
y\ge 0
$$

那这个的意思是,每个区间有一个$01$权值,最大化区间的权乘$sum-V$,$y$中不能有两个相交的区间权值都不为$0$.于是转化成了$\max t_k-kV$,其中$t_k$表示选$k$个不相交的区间的和最大是多少.

此时能求出$t$,考虑$k$个区间一定是若干个最大子段和,用线段树维护最大子段和,有个经典技巧是每次取走一个子段然后把它取负作为如果交上的反悔,求出$t$之后因为函数取$\max$可以求一个下凸壳,那么$g(x)$表示最大子段和为$x$最少需要操作几次就是这个下凸壳函数了,而$f$是$g$的反函数,对$f$预处理前缀和,区间求和即可.

## NOIP2023模拟赛46

### A. 完美主义

> 你在电脑上发现了一个长度为$a$ 的字符串，根据你的完美主义你需要将其长度变成 $b$.
> 你可以执行任意顺序，任意多次的以下 $5$ 种操作：
> 1. A...Z ，即花费一个按键的代价在字符串尾部添加一个字符，此时所有选中会被撤销，这与你的生活经验
> 或许有所不同，因为平时使用时若全选了则会将字符串整个删除后添加该字符。
> 2. Ctrl + A ，即花费两个按键的代价全选所有字符。
> 3. Ctrl + C ，即花费两个按键的代价复制当前选择的字符到剪贴板，即剪贴板中的内容是当前字符串。
> 4. Ctrl + V ，即花费两个按键的代价粘贴当前剪贴板中的内容。
> 5. Backspace ，即若全选了当前的所有字符，则删除所有字符，否则删除最后一个字符。
> 现在你想知道长度从$a$ 变到$b$ 至少需要按几次按键。

直接建图记录剪贴板长度是$n^2$的.

考虑把按下剪贴板之后的一系列操作(剪贴加若干次粘贴)一起维护,枚举这次复制之后粘贴了几次,那么复杂度就成了$n\ln n$

### B. 挑战哈密顿

> 给定一张$n$点完全图,顶点编号$1\ldots n$,每条边是红色或蓝色,你要以每个点为起点,找一条尽量短的路径满足以$u$为起点经过每个点至少一次,且边的颜色最多变化一次.
> 
> $n\le 2000$

猜测一定有恰好为$n$的解.

考虑增量构造哈密顿路,如果目前所有颜色都相同直接放到链的最后,于是现在已经有一条链$1\ldots x\ldots u$,其中$1\ldots x$的边颜色为$c_1$,$x\ldots y$为$c_2$,$c_1\ne c_2$,考虑分类讨论新的点$i$和原来$p\to x\to q$三个点的关系.

若$i\to q$为$c_2$,那么你可以把$i$插入到$x,q$之间,不管$x\to i$为什么都满足条件,然后移动$x$(分界点).同理有$i\to p$为$c_1$,于是现在只剩下$i\to p$为$c_2$,$i\to q$为$c_1$,发现若$i\to x$为$c_1$可以$p\to x\to i\to q$,为$c_2$可以$p\to i\to x\to q$,然后移动端点.

然后有一个容易WA的点在于如果当前$x$为链首或链尾,说明整条链都是一个颜色,要处理一下,不然可能会把新的点插入到起点前面.

### C. 装备

> ![picture 0](/img/2023-10-27-19-03-50-image.png)  
> 
> $n\le 10^5$,$a_i$互不相同

首先这个$c_i\le n$说明你从后往前贪心满足是对的.然后考虑如果要翻转$i$不行,那一定是$b_i=a_j$,那么若有这种情况就连一条边$i\to j$,则形成一个基环树森林,但有环的连通块都动不了,所以只要考虑森林.同时,$i$翻过去之后会让所有$b_k=b_i$不能翻.

于是你就建图找环,然后对每个点维护$s_i$表示翻转它需要再翻转几个点,维护$fixed_i$表示$i$是否已经确定,维护$flip_i$表示$i$是否被翻转,模拟上面的东西即可.维护$s$要查点到根的和,可以BIT维护dfs序.

然而这题有线性做法,注意到一棵树只有一个装备没被使用,而你翻转就是把没有使用的空位移动,而$k$就是移动步数.

### D. 灵活性

> ![picture 1](/img/2023-10-27-19-09-48-image.png)  
>
> ![picture 2](/img/2023-10-27-19-10-09-image.png)  

好难啊

我要把这个7k代码放在这/oh

考虑你要求一个一开始的答案,一个当前答案.那么路径应该放到$lca$上dp(完整包含路径的点):设$f_u$为子树内的答案,那么考虑转移就说枚举$u$上一条路径,然后$f_u=\sum_{fa_i\in Path_{u,v}} [i\notin Path_{u,v}](f_i)+w$,考虑维护$s_u$表示$\sum_{v\in son_u} f_v$,那么就只要求链的$\sum s_u-f_u+f_{lca}$了.最后$f_1$就是答案.

而询问的答案由两部分构成,显然建虚树,然后一部分是虚树上所有点的$s_u-f_u$,另一部分是虚树根子树外的答案,于是考虑如何处理每个点子树外的答案$g_u$,发现经过点$u$的路径$x\to l\to y$可以被用来更新$v$,当且仅当不经过$v$的子树,此时$g_v=\max g_{l}+\sum_{i\in path_{x,y}} s_i-f_i + f_l$,则可以把这个值插入到$x$和$y$上,更新一个点的儿子时就只要用子树最大值更新了.

复杂度$n\log n$

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <deque>
#include <iostream>
#include <list>
#include <vector>
#define endl '\n'
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;

const int N = 2e5 + 500, H = 20;
int n;
struct Line {
    int u, v;
    ll w;
};
vector<Line> ls[N];
vector<int> G[N];
ll s[N], f[N], g[N], sr[N];
int dep[N], top[N], dfn[N], dcnt, arr[N], siz[N],fa[N],son[N];
void pre(int u, int f) {
    dep[u] = dep[f] + 1;
    fa[u] = f;
    siz[u] = 1;
    for (int v : G[u]) {
        if (v == f)
            continue;
        pre(v, u);
        siz[u] += siz[v];
        if(siz[v]>siz[son[u]])son[u]=v;
    }
}
void dfs0(int u,int tp){
    dfn[u] = ++dcnt;
    arr[dfn[u]] = u;
    top[u]=tp;
    if(son[u])dfs0(son[u],tp);
    for(int v:G[u]){
        if(v==fa[u]||v==son[u])continue;
        dfs0(v,v);
    }
}
int lca(int a, int b) {
    while(top[a]!=top[b]){
        if(dep[top[a]]<dep[top[b]])swap(a,b);
        a=fa[top[a]];
    }
    return dep[a]<dep[b]?a:b;
}
int jump(int v, int u) {
	if(v==u)return v;
    int lv=0;
    while(top[v]!=top[u])
        lv=top[v],v=fa[top[v]];
    int res;
    if(fa[lv]==u)res=lv;
    else res=son[u];
	return res;
}
struct BIT {
    ll t[N];
    void add(int x, ll v) {
        for (; x <= n + 1; x += x & -x)
            t[x] += v;
    }
    ll ask(int x) {
        ll res = 0;
        for (; x; x -= x & -x)
            res += t[x];
        return res;
    }
    void radd(int l, int r, ll v) {
        add(l, v);
        add(r + 1, -v);
    }
} bit;
template <class Cmp, ll DE>
struct Seg {
    Cmp cmp;
    ll val[N << 2];
    ll chk(ll a, ll b) {
        return cmp(a, b) ? a : b;
    }
    void pushup(int x) {
        val[x] = chk(val[x << 1], val[x << 1 | 1]);
    }
    ll query(int x, int l, int r, int ql, int qr) {
        if (ql <= l && qr >= r)
            return val[x];
        int mid = (l + r) >> 1;
        ll ans = DE;
        if (ql <= mid)
            ans = chk(ans, query(x << 1, l, mid, ql, qr));
        if (qr > mid)
            ans = chk(ans, query(x << 1 | 1, mid + 1, r, ql, qr));
        return ans;
    }
    void insert(int x, int l, int r, int p, ll v) {
        if (l == r) {
            val[x] = chk(v, val[x]);
            return;
        }
        int mid = (l + r) >> 1;
        if (p <= mid)
            insert(x << 1, l, mid, p, v);
        if (p > mid)
            insert(x << 1 | 1, mid + 1, r, p, v);
        pushup(x);
    }
};
Seg<greater<ll>, 0> seg;
void dfs1(int u) {
    for (int v : G[u]) {
        if (v == fa[u])
            continue;
        dfs1(v);
        s[u] += f[v];
    }
    for (Line l : ls[u]) {
        ll v = bit.ask(dfn[l.u]) + bit.ask(dfn[l.v]) - bit.ask(dfn[u]) - bit.ask(dfn[fa[u]]);
        f[u] = max(f[u], v + s[u] + l.w);
    }
    bit.radd(dfn[u], dfn[u] + siz[u] - 1, s[u] - f[u]);
}
void dfs2(int u) {
    sr[u] = sr[fa[u]] + s[u] - f[u];
    for (int v : G[u])
        if (v != fa[u])
            dfs2(v);
}
void dfs3(int u) {
    for (int v : G[u]) {
        if (v == fa[u])
            continue;
        g[v] = max(g[v], seg.query(1, 1, n, dfn[u], dfn[v] - 1) - f[v]);
        if (dfn[v] + siz[v] != dfn[u] + siz[u])
            g[v] = max(g[v], seg.query(1, 1, n, dfn[v] + siz[v], dfn[u] + siz[u] - 1) - f[v]);
    }
    vector<pair<ll, pii> > cannot;
    for (Line l : ls[u]) {
        ll v = sr[l.u] + sr[l.v] - sr[u] - sr[fa[u]] + f[u] + g[u] + l.w;
        seg.insert(1, 1, n, dfn[l.u], v);
        seg.insert(1, 1, n, dfn[l.v], v);
        int a = jump(l.u, u), b = jump(l.v, u);
        cannot.push_back({v, {a, b}});
    }
    sort(cannot.begin(), cannot.end(), greater<pair<ll, pii> >());
    list<int> l;
    for (int v : G[u])
        if (v != fa[u])
            l.push_back(v);
    for (auto p : cannot) {
        for (auto it = l.begin(), nt = l.begin(); it != l.end(); it = nt) {
            if (nt != l.end())
                nt++;
            int v = *it;
            if (v != p.second.first && v != p.second.second) {
                g[v] = max(g[v], p.first - f[v]);
                l.erase(it);
            }
        }
        if (l.empty())
            break;
    }
    for (int v : G[u])
        if (v != fa[u])
            dfs3(v);
}
int keys[N], kcnt;
bool cmp(int a, int b) {
    return dfn[a] < dfn[b];
}
inline ll calc(int u, int v) {
    // cout<<u<<" "<<v<<" "<<(sr[v] - sr[u] - (s[v] - f[v]))<<endl;
    return (sr[v] - sr[u] - (s[v] - f[v]));
}
int stk[N];
ll query() {
    sort(keys + 1, keys + 1 + kcnt, cmp);
    kcnt = unique(keys + 1, keys + 1 + kcnt) - keys - 1;
    int top=0;
    int anc = lca(keys[1], keys[kcnt]);
    stk[++top]=anc;
#define ed (stk.size() - 1)
    ll tmp = s[anc] + g[anc];
    for (int i = 1; i <= kcnt; i++) {
        if (keys[i] == anc)
            continue;
        int u = keys[i], v = stk[top], l = lca(u, v);
        if (l != v) {
            while (top > 1 && dfn[stk[top - 1]] > dfn[l]) {
                tmp += calc(stk[top - 1], stk[top]);
                top--;
            }
            if (stk[top - 1] != l) {
                tmp += calc(l, stk[top]);
                tmp += s[l] - f[l];
                stk[top]=l;
            } else {
                tmp += calc(stk[top - 1], stk[top]);
                top--;
            }
        }
        stk[++top]=u;
        tmp += s[u] - f[u];
    }
    while (top > 1)
        tmp += calc(stk[top - 1], stk[top]), top--;
    ll ans = f[1] - tmp + 1;
    return ans;
}
signed main() {
    freopen("flexibility.in", "r", stdin);
    freopen("flexibility.out", "w", stdout);
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int m, q;
    cin >> n >> m >> q;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    pre(1, 0);
    dfs0(1,1);
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        ls[lca(u, v)].push_back({u, v, w});
    }
    for (int i = 1; i <= n; i++)
        ls[i].push_back({i, i, 0});
    dfs1(1);
    dfs2(1);
    dfs3(1);
    ll lans = 0;
    // for(int i=1;i<=n;i++)cout<<g[i]<<" ";
    // cout<<endl;
    for (int i = 1; i <= q; i++) {
        cin >> kcnt;
        for (int j = 1; j <= kcnt; j++)
            cin >> keys[j];
        keys[1] = (keys[1] + lans - 1) % n + 1;
        lans = query();
        cout << lans << endl;
    }

    return 0;
}
```

## USACO2020 铂金

剩下的大黑题要不鸽了吧!

### A. Non-Decreasing Subsequences

值域很小?

可以写成dp,预处理前缀矩阵和矩阵逆的乘积,$(n+q)k^3$.

考虑矩阵长什么样:$f_{i,a_i}=\sum f_{i-1,k},k<a_i$,哦所以矩阵的样子是对角线全是$1$加上第$k$列有一些$1$,那其实乘上这个矩阵是$n^2$的,因为你只需要对每个$1$贡献就行了.

然后求答案的时候向量乘矩阵也是$n^2$的.

### B. Falling Portals

画出每个地方关于时间的纵坐标图像,容易想到对着出发点分类,考虑如果出发点比目的地高,那你就要尽量快的下降,也就是每次走到比自己下的快的直线就下的策略.于是你走的一定是一个凸壳.同时,每条直线转移到的下一跳直线是唯一的,考虑$l$如果在$0$时进入转移到$p$,那么如果它可以从$q\to l$时不走$p$而走$q$只能因为$p$与$l$的交点在$q$与$l$交点之前,但此时根据斜率关系,发现$p$与$q$交点一定在$p$与$l$之前,于是每条直线的转移时唯一的,预处理后倍增的跳即可.

### C. Delegation

难蚌,读成了每个点在一个路径里.(不看样例的吗!)

直接multiset去把里面的都匹配起来传一个剩下的上去.那应该把哪一个放上去是需要考虑的,考虑如果自己这层全都匹配了放上去的是$1$是最不好的,所以如果可以就不要全部匹配,如果当前点有偶数个儿子(可能全部匹配),那么因为全部自己匹配是最劣的所以如果可以先把最大的能放走的的单独放走.如果是奇数那么不可能全部匹配直接做就行了.

### D. Help Yourself

设$f_i$表示最后所有线段的并的右端点是$i$的答案,此时的困难是,如果用区间$[l,r]$转移,对于$i\ge l$我们不会做:新的区间可能会覆盖两个原区间,使得$f_i$中两个连通块合并成一个.此时考虑钦点一个转移顺序避免这种情况,如果出现合并,一定与其中至少一个区间有交,那么考虑按$l$从小到大转移,此时可以做了,对于区间$[l,r]$,所有$f_i,i<l$都要连通块数加$1$贡献过来,$i\in [l,r]$直接贡献过来,$f_i,i>r$无影响(方案数乘$2$).那么线段树维护即可,次幂用斯特林数转组合数.

### E. Sprinklers 2: Return of the Alfalfa

容易发现这些中间只有一条分割线,分割线转角处要放洒水器,好像接下来直接dp,设$f_{i,j,0/1}$表示在$i,j$处放一个洒水器,分割线最后一次方向,每次可以由往上或往左一条线求和转移过来.

### F. Exercise

好厉害的容斥数数.

首先它肯定是让你求所有环的$lcm$的积.那你肯定要转成求指数,又因为直接求指数不好求,考虑算有多少种方案$lcm$是$p^k$的幂,$p$为质数.

考虑怎么在已有若干个环长$n$的排列数上在添加一个长$i$的环,那么这$i$个数自己有$(i-1)!$种,再拼进去有$\binom{n}{i}$种.

考虑先枚举一个$p^k=D$,那么是算有多少种方案包含一个大小为$D$的倍数的环,但包含太难算了考虑变成不包含的排列数$f_n$,但只用不包含的环大小去背包是$n^2$的,考虑再次容斥计算仅有$D$的倍数构成的排列数$g_n$,因为这样的$g$只有$\dfrac{n}{D}$个,然后容斥出$f_n=n!-\sum_i \binom{n}{i}f_ig_{n-i}$(总数减去包含的),同时发现$f$也只有$\dfrac{n}{D}$个,因为你要算$f_n$的时候只用到$f_i,i=n-kD$,再往下递归也始终是这个形式,于是复杂度成了$\dfrac{n^2}{d^2}$,而$\sum \dfrac{1}{d^2}$是收敛的!

最后按照之前写的拼接方式计算$g$,枚举包含第一个点的环长$i$,则方案数是$g_n=g_{n-i}\binom{n-1}{i-1}(i-1)!$.

### G. Circus

### H. Sleeping Cows

上来先对$a,b$排序,这个题$a$和$b$匹配是对称的,考虑从$b$这一维做,则能匹配$b_i$的$a$是一个前缀$p_i$,那么当前这个$b$可以匹配一个$a$,也可以留空,留空要求前面没有必须留空的$a$,于是可以设$f_{i,j,0/1}$表示前$i$个$b$,$1\ldots p_i$中有$j$个$a$还没匹配但该匹配,是否有被钦定不匹配的$a$,每次转移枚举这$[p_i-p_{i-1}]$中的牛有多少加入匹配即可.注意这里$\sum p_i-p_{i-1}=n$所以复杂度其实是$n^2$而不是$n^3$

更好的做法可能是把$a$和$b$一起排序,一次只转移一个.

### I. Spaceship

见鬼数数

### J. Cowmistry

## NOIP2023模拟赛47

### A. 药品试验

> 你在数轴上,有$a$的概率往左走一步,$b$的概率停在当前位置,$c$的位置往右走一步,你一开始在$n$,走到$0$或$2n$停止,求走到$2n$的概率.
> $n\le 10^7$

直接写主元高消会因为求逆元爆炸掉.

考虑中间的部分可以矩阵快速转移,那么直接用矩阵算出$f_{2n}$关于$f_0,f_1$的概率那个矩阵然后解出$f_1$,再直接递推$n$即可.

### B. 小猫钓鱼

模拟

### C. 模拟旅行最短路

> 给定一张$n$个点的图,询问集合$s$中的点两两距离的最小值.
> $n\le 3\times 10^5,m\le 10^6$

首先容易想到多源dij求每个点正着/反着到最近的两个$S$中点的距离然后做完了.

一个很好写的方法是,考虑如果是$S$中到$T$中的你直接跑一遍最短路就行了,那每次随机划分重复$\log$次即可.

### D. 迷雾华光

> 求树链上众数
> 
> $n\le 8\times 10^4,q\le 10^5$

树分块模板.分完了就是蒲公英那个题的做法.

王氏联邦分块比随机撒点跑的快得多.

## NOIP2023模拟赛48

### A. Chefina 与区间

简单题

### B. 小 G 的布料

> 给定$01$矩阵,求面积$\ge k$的全$0$矩形个数.
> 
> $n,m\le 2000$

预处理每个点往下连续$0$的个数$f_{i,j}$,枚举每一行,对$f_i$建笛卡尔树,在上面数数,就只要算包含在一个矩形中的面积大于$k$的个数了,这个列出式子预处理即可.

### C. Easy Data Structure

模板ddp

### D. LCM Game

> 随机生成$[1,n]$的数$k$次,求所有方案下生成的数的$lcm$的和/积.
> 
> $n\le 500,k\le 100$

积是好做的,直接对每个素数的幂分别算即可.

有一个经典技巧(寿司晚宴)说的是大于$\sqrt n$的质数每个数只能有一个,在最终的答案要么出现要么不出现,而小于$sqrt n$的数在这题里只有$8$个,$lcm$有大约$6\times 10^4$种.于是考虑对每个数分解成$lp\times bp$,其中$bp=p\ge sqrt n$或$bp=1$.则考虑对$lp$的$lcm$算$bp$部分的lcm的乘积.但限制$lp$的$lcm=x$恰好为一个数困难,限制$lcm\vert x$的答案$g_x$只要选的每个数的小质数部分都是$x$的因数,于是先算后面这种再一遍狄利克雷差分就能得到答案.

枚举$x$计算$g$,先预处理能选的数($lp\vert x$)中$bp=p_i$的数的个数$cnt_i$,那么现在要求在$[1,n]$中选$k$个数的所有方案权值和,一个方案的权值是它选的数中包含的$bp$的乘积.限制出现过是困难的(只能一次转移相同$bp$的所有数,复杂度$nm$),考虑容斥,原来一个$bp$的贡献可以看成 $([have]p+[nothave]1)=(p+[nothave]\cdot (1-p))$,于是把方案算成钦定$bp$可以出现则乘$bp$,不能出现则乘$1-bp$,算出有$i$个被钦定可以出现的方案数$f_i$,则答案为$\sum f_i i^k$.

另一种容斥的理解是,考虑原来要求的是$\prod (p(e^{x\cdot cnt}-1)+1)$,它可以变成$\prod (pe^{x\cdot cnt}+(1-p))$,这个就能算了,对每个最后的$e^{kx}$算前面的系数,而$[z^n]e^kx=k^n$,后面算每个$e$前面系数的部分就是那个dp.

复杂度是$l n^2$其中$l$为$lp$部分$lcm$个数,发现过不了,但发现如果只看$bp\ne 1$的数的$lcm$就只剩不到$1000$种,于是把dp分成$bp\ne 1$和$bp=1$两部分,前面的记忆化就能过了.

## 一些构造题

### A. 人生的经验

> ![picture 3](/img/2023-11-01-07-52-20-image.png)  

猜测答案是$c^l+l-1$,考虑如果把字符串建成点,相邻两个字符串转移建成边,那要求哈密顿路不会,于是考虑把字符串表示成边,那么可以建$l-1$长度的字符串为点,这样就是要求欧拉路径了,而且此时可以发现一定有解.

### B. 矩阵

> 有一个$n\times n$的$01$矩阵,每次选择一个$i\in [1,n]$,然后记录$c_j=a_{i,j}$,然后赋值$a_{j,i}=c_j$,要求最后全$1$.最小化操作次数或判断无解.
> 
> $n\le 1000$

如果有$1$一定有解,容易想到一定是先把一行全$1$然后再把每列操作,而全$1$一行的代价首先是这行$0$个数,但是如果这行对应的列没有$1$就在加上$1$.

### C. Divide

> $n$个元素分成两组,每个元素有属性$a_i$,最大化不在一组的元素$i,j$满足$a_i+a_j>m$的对数,求方案数
> 
> $n\le 2000,m\le 2\times 10^6$

这谁想得到啊!

考虑直接dp不行因为你大概需要前面知道在不在一组的点中有多少能匹配.于是你把$a$重排,使得要么前面每个元素都不可能和它构成贡献,要么都能和它构成贡献,于是dp只要记录前面有多少个点在A组.但这个序列为什么一定存在呢?考虑把原序列排序,若$a_1+a_n\ge m$则$a_n$可以和中间所有元素构成贡献,可以把$a_n$拿出来放到序列最后,若$a_1+a_n<m$则$a_1$不能和中间任何元素构成贡献,可以把$a_1$拿出来放最后,递归下去就构造出来了.

[conclusion] 可以排序序列使得对常数$m$和任意$i$,有$a_i+a_j>m,\forall j<i$或$a_i+a_j<m,\forall j<i$

有更厉害的做法!

![picture 6](/img/2023-11-01-20-39-06-image.png)  


### D. Hby的旅游之都

> 给定$DAG(n,m)$,给边三染色使得不存在一条路径可以连续经过$42$条相同颜色的边.
> 
> $n,m\le 2\times 10^5$

考虑把点分成$42$组,组之间全染色成$0$.再把每组分成$42$组递归下去,发现$42^3$成功的大于了$n$.这个要想对要求你走出一个组之后没有可能回到组中,于是你可以按拓扑序上的区间分组.

### E. 

> ![picture 4](/img/2023-11-01-19-22-54-image.png)  

首先根据它给的结论,猜测答案为$n-1$.

考虑把边分为$n-1$组,则每组有$\dfrac{n}{2}$条边,每组内连续编号则一定是对的.于是只要找完全图的$n-1$组不交的匹配.

可以构造成这幅图的$n-1$次旋转

> ![picture 5](/img/2023-11-01-19-28-05-image.png)

### F. 

> 定义一个$n\times n$的矩阵称为$n$阶皇后矩阵，当且仅当矩阵中的元素都取自集合$S=1,2\ldots 2n-1$，且对于每个$i=1,2\ldots n$，它的第$i$行和第$i$列中所有元素合起来恰好是$S$中的所有元素。请你对于给定的$n$ 给出一个边长为 $n$的皇后矩阵。当然如果你不想回答这个问题，或确实无法构造，你也可以退而求其次，回答是否存在$m$阶皇后矩
> $n\le 1500$


## NOIP2023模拟赛49

### B. 括号串

> 构造$n\times n$的空矩阵,值域$1\ldots n$使得行,列,主对角线中元素互不相同.
> 
> $n\le 300$

奇数时直接$a_{i,j}=(i+j)\pmod n$

偶数先构造出奇数的再在上面补充.

我才不会告诉你我直接瞪着100的大样例找规律.

### B. 括号串

> 一开始，一个仅包含一对括号的串即 $()$，接下来有 $3$ 个操作，操作分为三类：
> 
> - 操作 $1$ ，在字符串的末尾加上一对括号，即由 $S$ 变为 $S()$；
> - 操作 $2$ ，在字符串的最外面套上一对括号，即由 $S$ 变为 $(S)$；
> - 操作 $3$ ，是撤销之前的某个操作，清除它造成的一切影响。
> 
> 每次操作后，你需要输出当前字符串能够括号匹配的非空子串数量。

考虑把括号之间的嵌套关系建树,顶层建一个超级根,那么操作$1$是给当前根挂一个儿子,操作$2$是给当前根挂一个父亲并成为新的根.若只有操作$1,2$,则某一时刻的答案就是每个点的$\sum \dfrac{s_u(s_u+1)}{2}$,其中$s_u$为$u$的儿子个数.那现在有了操作$3$,把最终的整棵树建出来,让被撤销的/还没加入的点为白点,其余点为黑点,则显然一个点的$s_u$应该指的是$u$子树中到$u$的路径上没有其他黑点的黑点数量,而答案是所有黑点的贡献之和.那么用dfs+BIT维护$s_u$支持链加单点查,再上一个数据结构支持查一个点往上最近的黑点即可.查这个在普通树上不用lct类科技应该只能2log?但是这个树上直接树剖就是单log.

然而不树剖直接二分+bit也过了.

### C. 博弈

是Topcoder SRM700 AnyNumber

> 有一个棋盘,第$i$行有$l_i$个格子,给定字符串序列$s_n$,你会按顺序依次把字符串放到一个随机的空格子中,当有一行被填满时结束,定义一个操作序列的权值为操作后这一行满格子上的字符串顺次拼接后形成的数字,求权值期望.
>
> $n,m,\sum s_i\le 300,\sum l_i\le n+m$

一开始疑惑为什么要按照顺序,因为看起来先放这个再放那个最后局面概率是一样的.但发现有终止局面就不一样了.于是考虑枚举结束的时间.

这个权值看起来很奇怪,先看它怎么处理,假设我们会处理一行的权值,那么接下来就只要乘上$cnt_{i,j}$表示没有第$i$行的情况下放$j$个字符串,没有填满任何一行的方案数,就可以合并答案了.

再枚举最后满的一行,现在要算权值,这个权值直接看很见鬼,考虑把每个数字的贡献拆开算,设字符串$s_i$的实际值为$v_i$,长度为$q_i$.我们可以把其贡献表示成$v_i\sum 10^{x}$,那么看看能不能dp这个$x$出来,设加入$i$个字符串,其中有$j$个放在当前这一行的情况下,把这$j$个拿出拼成一个序列,$\sum_T 10^{s_{T,k}}$,其中$s_{T,k}$表示方案$T$下最后$k$个数的$q_i$之和为$f_{i,j,k}$(换句话说,如果新加一个字符串插入在从右往左数第$k$个字符串的右边,它应该乘上多少).转移就是新来的字符串的位置,其中$(1)$表示这个字符被放到其它行,$(2)$是放在后$k$个之前,$(3)$是放在后$k$个中

$$
\begin{align}
    f_{i,j,k}=&f_{i-1,j,k}\tag{1}\\
             +&(j-k)f_{i-1,j-1,k}\tag{2}\\
             +&k\cdot f_{i-1,j-1,k-1}\cdot 10^{q_i}\tag{3}
\end{align}
$$

此时已经可以写答案了吧,就是你枚举一个数,枚举它的位置,但这样复杂度应该是$n^4$的.考虑再dp,设$g_{i,j}$表示前$i$个字符串,有$j$个在当前行,发现此时加入一个数不好转移,因为当你向这$j$个数中间插入一个数时,会让一个前缀乘上$10^{q_i}$,于是考虑把前缀也设进去:$g_{i,j,k}$表示前$i$个字符串,有$j$个在当前行,把它们拼成一个序列,在所有方案下,前$k$个元素的贡献和是多少(比如前$k$个元素种有一个元素在一种方案下为$x$,它后面总长为$y$,那么它会产生$x10^y$贡献),此时就可以列转移了.

$$
\begin{align}
    g_{i,j,k}&=g_{i-1,j,k}\tag{1}\\
             &+kg_{i-1,j-1,k-1}\tag{2}\\
             &+\sum_{l<k} k{i-1,j-1,l}(10^{q_i}-1)\tag{3}\\
             &+\sum_{l\in [j-k,j)} f_{i-1,j-1,l}v_i\tag{4}
\end{align}
$$

$(1)$表示不选,$(2)$是去掉这个元素的贡献,$(3)$是选上这个元素后,有一些元素的贡献因为插入了它变大,$(4)$是这个元素自身在每个位置的贡献之和.

$f,g$用滚动数组优化都是$n^3$,前面那个枚举处理$cnt$也是$n^3$,合并答案$n^2$,总复杂度$n^3$,注意合并答案时要强制当前元素在这一行被选(只要在贡献$g_i$时差分掉$g_{i-1}$的即可).

### D. 平面树

> ![picture 7](/img/2023-11-02-20-43-59-image.png)  
> 
> $n\le 3\times 10^5,q\le 6\times 10^6$

考虑先预处理,把一条边的代价重置为从这条边左边到这条边右边的最小代价,这个可以两遍dfs实现,跨过一条边的方式包括跨过子树的所有儿子,跨过它,跨过所有兄弟和父亲三种.

然后设状态为$f_{u,0/1,0/1}$表示从这条边的左右侧转移到父边的左右侧要加的代价,这个转移可以写成矩阵,然后查询时你就从两个点先转移到lca,然后合并答案即可.

复杂度是单log吧.