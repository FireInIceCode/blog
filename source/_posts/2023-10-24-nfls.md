---
title: 南外集训
subtitle: 
layout: post
show: true
top: false
tags: 
- 日志
password: usbombnlm
---

## NOIP模拟赛43
todo
### A. 括号	
### B. 学校	
### C. 运算	
### D. 乘积

## NOIP模拟赛44

### A. K 近查询

> 给定序列$a_n$,对每个$k\le lim$求$j$使得$j$是$j < i,a_j\ge a_i$中第$k$大的.
> 
> $n\le 10^7,lim=1$或$n\le 3\times 10^6,lim=5$

简单题,对$10^7$的部分直接单调栈,对$lim=5$的部分建出链表,然后从小到大删元素并统计答案.

### B. 树上流水

> 给一棵$n$个点的外向树,根有无限水,边有容量限制,每秒可以把水延边推动,求最少几秒使得叶子处总水量至少为$K$.
> $K\le 10^9$,$n\le 1000$

容易想到dp,设$f_{u,i}$表示点$u$发出$fw_u=w_{fa_u\to u}$的流量在$i$秒后最多有多少到叶子,转移大概是$f_{u,i}=\min (\sum f_{v,i},fw_u)$,然后求出$1$的就可以算答案了.

然而赛时一开始没看到$n\le 1000$(它写$\sum n\le 5\times 10^4$),所以可以写线段树合并加速转移.或者动态dp每次删最底下的东西,或者可并堆,都能做到单log.

当然也容易想到贪心,因为你一定优先流深度低的叶子.

### C. 逆序对

> 给定一长为 $2^n$ 的序列 $p_1, p_2, ..., p_{2^n}$, $m$ 次操作，每次操作给出三个整数 $q_i$, $l_i$, $r_i$，然后对序列作如下变换：
> 
> - 将序列分为 $2^{q_i}$ 个大小为 $2^{n-q_i}$ 的块。    
> - 选择第 $l_i$ 到第 $r_i$ 个块。 
> 
> 每次操作后，输出整个序列的逆序对数。

直接线段树维护就行了.建线段树后,每个点记录$w_x$为左儿子对右儿子的逆序对数,发现翻转这个节点(交换左右子树,子树内不变)只影响本节点的$w$且可以预处理,而题目所要求的翻转一个区间就是翻转区间对应节点的所有子树.于是要打懒标记,记录$s_x$表示$x$子树中集合$s$中的层都要翻转,$c_{x,i}$表示$x$子树中深度为$i$的那层节点翻转后的$w$减去翻转前的$w$就做完了就能合并标记和处理变化了.复杂度2log.

### D. 净土裁断

> 在一棵$n$点树上随机游走,在点$u$有$p_u$概率停留$1s$,有$1-p_u$概率等概率走到相邻一点,走到$1$停止,求每个点走到$1$的步数的$k$次方的期望.
> 
> $n\le 10^5,k\le 10^3$

先考虑$k=1$怎么做,那么

$$
f_u=p_u(f_u+1)+(1-p_u)\sum_{u\to v}(f_v+1)
$$

然后这个有后效性,学到一个树上高消:依赖关系成树之后叶子的式子可以写成$f_u=a_uf_{fa}+b_u$,然后把这个式子带入父亲的式子就消掉自己,于是父亲最后也表示成关于爷爷的一次函数,以此类推,最后推到根,再用根的值算出整棵树的dp值.

遇到$k$次方常见套路是EGF和斯特林数.EGF没推出来/kk

斯特林数,则$x^k=\sum_{i=0} \binom{n}{i}{k\brace i}i!$,于是要算$\sum \binom{l}{i}$,于是

$$
f_{u,k}=p_u(f_{u,k}+f_{u,k-1})+(1-p_u)\sum_{u\to v}(f_{v,k}+f_{v,k-1})
$$

于是仍然套刚才的树上高消,复杂度$nk+k^2$


## USACO 2018 铂金

> A. Balance Beam

想到dp$dp_i=\max (f_i,\dfrac{1}{2}(dp_{i-1}+dp_{i+1}))$,但这个转移不了.

考虑一些点$dp_i=f_i$,那么这些点就把序列分成若干段,每一段内的点的dp值就由两边的断点决定.而发现走到左右断点中的哪一个的概率是能求的:和距离成正比.

然后最厉害的地方在于,考虑把它们以$i$为横坐标,$f$为纵坐标画到平面上,则中间的点就是断点连线在这个横坐标的值.现在把$i,v_i$画到平面上,选择若干个点使得对应横坐标最大,发现这是凸包.于是最后只要求个凸包就做完了.

[think] 想出一个最优策略
[conclusion] 在$[1,l]$的线段上,每步随机走到$-1+1$的位置,点$x$从$0$出来的概率是$\dfrac{x}{l+1}$

> B. Sort It Out

集合外的点相对顺序不变,于是集合外的点必然是升序的,在此基础上发现集合内的每个点都会到正确的位置上.那么剩下的是一个LIS,发现若两个LIS的字典序关系和它们的补的大小关系相反(考虑其第一个不相同的元素前都相同,第一个不相同的元素$B$大则补中$B$缺一个大的$A$缺一个小的).于是求第k$大LIS,设$f_i,g_i$表示以$i$结尾的$LIS$长度和个数,$g$的转移一定是$f_j=f_i-1$的一个后缀转移过来,如果对每种$f$的值开一棵线段树,那么就是区间查,最后求第$k$大也就是在线段树上面二分.复杂度单log.好吧实际上求$g$可以直接维护最大值对应元素之和,二分也可以直接二分,但这样是先确定尾不断往头走,所以应该翻过来找下降序列.

[think] 寻找不变性,排除一定不合法的情况分析充分性.这里先要求集合外升序,而集合外不升序的情况下集合内的点最终目标没有好的性质.

> C. The Cow Gathering

容易想到建成根向有根树,把限制边连上就是问每个点开始有没有环.

发现对于限制$u\to v$,所有以$v$为根的$u$的子树都不能当根了.于是ban掉$O(1)$个dfs区间.

[think] 考虑每个限制的贡献

> D. Lifeguards

看到$k=100$直接dp,显然有包含关系可以全杀了,然后按$r$排序,$f_{i,j}$表示前$i$个区间删$j$个的最大值转移不了,不知道转移过来时那里有没有删,那么钦点$i$必选,考虑前面一段没有选,然后从$f_{k,j-1}$转移来,此时若$r_k>l_i$则贡献就是$f_{i,j}=f_{k,j-(i-k+1)}+(r_i-r_k)$,否则是 $f_{i,j}=f_{k,j-{i-k+1}}+(r_i-l_i+1)$,对$k$的限制就是前后缀,发现其实是要知道$f_{k,k+(j-i-1)}$,对每个差维护单调队列即可$O(1)$转移.

[think] 钦点状态加强性质帮助转移,困难是不知道最后一个被删的是谁那可以钦点成自己

> E. Cow at Large

Bessie通过一个点的条件是这个点最近的叶子到它的距离小于根到这个点的距离,所有不能通过的点中父亲能通过的就是你会用来堵死bessie的点(农民会走到这些位置).

考虑怎么不依赖父亲,考虑此时先拿出所有Bessie不能通过的点,容斥出答案,我们值希望让每个子树的和为$1$即可,于是叶子贡献$1$,每个点贡献负的度数减$1$即可.

于是统计答案,要对每个点$u$求所有$dis_{u,v}>p_v$的$v$的权值和,点分治就可以了.

[think] 容斥点权使得子树和为$1$相当于最上层点个数

> F. Sprinklers

显然水和废料覆盖的分别是一个阶梯状,要数两个阶梯状的交里放下几个矩形.考虑直接扫描线,因为值域$O(n)$,维护纵向的扫描线上每个$y$坐标在扫描线有多长一段合法的,每次移动区间加,发现答案贡献要再维护下标和值的乘积就做完了.

> G. Out of Sorts

考虑每个位置什么时候出现分隔点,因为每次冒泡都让右边比$i$小的元素向左移动一格,于是可以求出冒泡次数.于是每个位置的贡献就是两边分隔出现时间中的较大值.于是就结束了.

不会做就拆贡献!

> H. Train Tracking

咕咕

> I. Disruption

这不是模板题吗!直接并查集就能做到$n\alpha (n)$

## NOIP2023模拟赛45

### A. 树上删边

> 有一棵$n$个结点的树，每个结点有一个权值，删除一条边的费用为该边连接子树中结点权值最大值之和。问以任意顺序删除树中所有边的最小花费。
> 
> $n\le 10^5$

容易发现,应该按照边的两个端点中大的一个排序然后依次删除.然后为了维护这个可以倒过来加边并查集.

### B. 欧几里得	

> 定于
> $$R(a,b)=\begin{cases}R(b,a)\ if\ a<b\\R(\lfloor\dfrac{a}{b}\rfloor,b)\ if\ 1<b\le a\\a\ if\ b=1\end{cases}$$
> 给定$g,h$,求任意一组$a,b\le 10^{18},R(a,b)=\gcd(a,b)$

考虑$\gcd$的限制是精确的,而$R$每次是给一个范围,于是想到从$R(1,h)$往回倒退$a,b$的范围,往前一组肯定是$R(h,x),x\in [h^2,2h^2)$,于是发现你可以不断对 $[h^2,2h^2)$ 乘一个$h$扩大它的范围,然后让我们的答案分别是$ag,bg(a>b)$,那么经过一次递归之后变成$R(\dfrac{a}{b},bg)$,于是只要能找到 $bg\in [h^k,2h^k)$,则能算出$ag=hb+i(i\in (0,b))$使得$gcd(ag,bg)=g$,容易发现$gcd(ag,bg)=gcd(i,bg)$,于是直接让$i=(b-1)g$即可.赛时没细想最后一步直接写了个$0,b$范围内随也过了.

### C. 没有上司的涨薪舞会

> 一个公司有 $n$ 名员工，$1$没有直接上司，其余员工都有一个直接上司。这样的直接上司关系构成以 $1$ 为根的有根树。已知这颗树。一个员工的直接下属，指以他为直接上司的所有员> 工。一个员工的下属，指他子树内除他以外的所有员工。
> 
> 这些员工都十分渴望涨薪，所以有些人会要求涨薪。记 $s_i$ 为第 $i$ 个员工是否要求涨薪，“是”为 $1$，“否”为 $0$。不知道序列 $s$。
> 
> 现在所有员工都被邀请去了一个舞会。但是并不是所有人都十分想去，而且他们是否参加会以自己的直接下属参加情况为参考。每个人 $u$ 都会等待自己所有下属都决定完，然后：
> 
> 若不存在直接下属决定参加舞会，则以 $p_u$ 的概率参加舞会；
> 
> 否则，一定不参加舞会。
> 
> 已知序列 $p$。
> 
> 这个公司里，每位员工都有权力和义务给自己的下属涨薪/降薪。在这个舞会上，每位参加舞会的员工 $u$ 会对每个要求涨薪并且参加舞会的下属都涨薪 $a_u$。这个值可以是负的，因为有些人心情很差，专门给要求涨薪的人降薪。已知序列$a$。
> 
> 求使公司所有员工涨薪量之和期望最大的序列 $s$。不用输出序列 $s$，只用输出期望的大小。保证答案在 $10^{11}$ 以内。
> 

期望的线性性说可以对每个点分别求祖先到它的期望.此时你可以智慧的直接设$f_{u,0/1}$表示$u$一定来或不来时祖先造成的贡献去dp,或者直接看成每次修改$a_u$,上一个矩阵优化的静态动态dp,只要维护到根的矩阵连乘积.

### D. 最大子段和

> 给定$\{a_n\}$,每次可以选择$p$让$a_p:=a_p-1$,定义$g(i)$表示操作$i$次后最大子段和的最小值,$q$次求$\sum_{i=l}^r g(i) \pmod {10^9+7}$
>
> $l,r\le 10^{15},n,q\le 5\times 10^5$

看到这个询问可以直接猜答案是$O(n)$段一次函数的区间和.但问题是一个子段和可能随着减小突然裂开成两个.

考虑二分答案转为求让答案减少到$V$需要操作多少次,,线性规划形式为

$$
\min_c \sum_i x_i\\
s.t.\forall l,r\ \sum_{i=l}^r a_i-x_i\le V\\
x_i\ge 0
$$
标准型
$$
\min 1\cdot x\\
Ax\ge c\\
x\ge 0
$$
$A$是$\dfrac{n(n-1)}{2}\times n$的矩阵,每行对应一个区间,这一行中属于这个区间的位置是$1$其他是$0$,$x$是长$\dfrac{n(n-1)}{2}$的数组每个位置为$sum-V$.对偶之后变成

$$
\max c\cdot y\\
A^Ty\ge 1\\
y\ge 0
$$

那这个的意思是,每个区间有一个$01$权值,最大化区间的权乘$sum-V$,$y$中不能有两个相交的区间权值都不为$0$.于是转化成了$\max t_k-kV$,其中$t_k$表示选$k$个不相交的区间的和最大是多少.

此时能求出$t$,考虑$k$个区间一定是若干个最大子段和,用线段树维护最大子段和,有个经典技巧是每次取走一个子段然后把它取负作为如果交上的反悔,求出$t$之后因为函数取$\max$可以求一个下凸壳,那么$g(x)$表示最大子段和为$x$最少需要操作几次就是这个下凸壳函数了,而$f$是$g$的反函数,对$f$预处理前缀和,区间求和即可.

## NOIP2023模拟赛46

### A. 完美主义

> 你在电脑上发现了一个长度为$a$ 的字符串，根据你的完美主义你需要将其长度变成 $b$.
> 你可以执行任意顺序，任意多次的以下 $5$ 种操作：
> 1. A...Z ，即花费一个按键的代价在字符串尾部添加一个字符，此时所有选中会被撤销，这与你的生活经验
> 或许有所不同，因为平时使用时若全选了则会将字符串整个删除后添加该字符。
> 2. Ctrl + A ，即花费两个按键的代价全选所有字符。
> 3. Ctrl + C ，即花费两个按键的代价复制当前选择的字符到剪贴板，即剪贴板中的内容是当前字符串。
> 4. Ctrl + V ，即花费两个按键的代价粘贴当前剪贴板中的内容。
> 5. Backspace ，即若全选了当前的所有字符，则删除所有字符，否则删除最后一个字符。
> 现在你想知道长度从$a$ 变到$b$ 至少需要按几次按键。

直接建图记录剪贴板长度是$n^2$的.

考虑把按下剪贴板之后的一系列操作(剪贴加若干次粘贴)一起维护,枚举这次复制之后粘贴了几次,那么复杂度就成了$n\ln n$

### B. 挑战哈密顿

> 给定一张$n$点完全图,顶点编号$1\ldots n$,每条边是红色或蓝色,你要以每个点为起点,找一条尽量短的路径满足以$u$为起点经过每个点至少一次,且边的颜色最多变化一次.
> 
> $n\le 2000$

猜测一定有恰好为$n$的解.

考虑增量构造哈密顿路,如果目前所有颜色都相同直接放到链的最后,于是现在已经有一条链$1\ldots x\ldots u$,其中$1\ldots x$的边颜色为$c_1$,$x\ldots y$为$c_2$,$c_1\ne c_2$,考虑分类讨论新的点$i$和原来$p\to x\to q$三个点的关系.

若$i\to q$为$c_2$,那么你可以把$i$插入到$x,q$之间,不管$x\to i$为什么都满足条件,然后移动$x$(分界点).同理有$i\to p$为$c_1$,于是现在只剩下$i\to p$为$c_2$,$i\to q$为$c_1$,发现若$i\to x$为$c_1$可以$p\to x\to i\to q$,为$c_2$可以$p\to i\to x\to q$,然后移动端点.

然后有一个容易WA的点在于如果当前$x$为链首或链尾,说明整条链都是一个颜色,要处理一下,不然可能会把新的点插入到起点前面.

### C. 装备

> ![picture 0](/img/2023-10-27-19-03-50-image.png)  
> 
> $n\le 10^5$,$a_i$互不相同

首先这个$c_i\le n$说明你从后往前贪心满足是对的.然后考虑如果要翻转$i$不行,那一定是$b_i=a_j$,那么若有这种情况就连一条边$i\to j$,则形成一个基环树森林,但有环的连通块都动不了,所以只要考虑森林.同时,$i$翻过去之后会让所有$b_k=b_i$不能翻.

于是你就建图找环,然后对每个点维护$s_i$表示翻转它需要再翻转几个点,维护$fixed_i$表示$i$是否已经确定,维护$flip_i$表示$i$是否被翻转,模拟上面的东西即可.维护$s$要查点到根的和,可以BIT维护dfs序.

然而这题有线性做法,注意到一棵树只有一个装备没被使用,而你翻转就是把没有使用的空位移动,而$k$就是移动步数.

### D. 灵活性

> ![picture 1](/img/2023-10-27-19-09-48-image.png)  
>
> ![picture 2](/img/2023-10-27-19-10-09-image.png)  

好难啊

我要把这个7k代码放在这/oh

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <deque>
#include <iostream>
#include <list>
#include <vector>
#define endl '\n'
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;

const int N = 2e5 + 500, H = 20;
int n;
struct Line {
    int u, v;
    ll w;
};
vector<Line> ls[N];
vector<int> G[N];
ll s[N], f[N], g[N], sr[N];
int dep[N], top[N], dfn[N], dcnt, arr[N], siz[N],fa[N],son[N];
void pre(int u, int f) {
    dep[u] = dep[f] + 1;
    fa[u] = f;
    siz[u] = 1;
    for (int v : G[u]) {
        if (v == f)
            continue;
        pre(v, u);
        siz[u] += siz[v];
        if(siz[v]>siz[son[u]])son[u]=v;
    }
}
void dfs0(int u,int tp){
    dfn[u] = ++dcnt;
    arr[dfn[u]] = u;
    top[u]=tp;
    if(son[u])dfs0(son[u],tp);
    for(int v:G[u]){
        if(v==fa[u]||v==son[u])continue;
        dfs0(v,v);
    }
}
int lca(int a, int b) {
    while(top[a]!=top[b]){
        if(dep[top[a]]<dep[top[b]])swap(a,b);
        a=fa[top[a]];
    }
    return dep[a]<dep[b]?a:b;
}
int jump(int v, int u) {
	if(v==u)return v;
    int lv=0;
    while(top[v]!=top[u])
        lv=top[v],v=fa[top[v]];
    int res;
    if(fa[lv]==u)res=lv;
    else res=son[u];
	return res;
}
struct BIT {
    ll t[N];
    void add(int x, ll v) {
        for (; x <= n + 1; x += x & -x)
            t[x] += v;
    }
    ll ask(int x) {
        ll res = 0;
        for (; x; x -= x & -x)
            res += t[x];
        return res;
    }
    void radd(int l, int r, ll v) {
        add(l, v);
        add(r + 1, -v);
    }
} bit;
template <class Cmp, ll DE>
struct Seg {
    Cmp cmp;
    ll val[N << 2];
    ll chk(ll a, ll b) {
        return cmp(a, b) ? a : b;
    }
    void pushup(int x) {
        val[x] = chk(val[x << 1], val[x << 1 | 1]);
    }
    ll query(int x, int l, int r, int ql, int qr) {
        if (ql <= l && qr >= r)
            return val[x];
        int mid = (l + r) >> 1;
        ll ans = DE;
        if (ql <= mid)
            ans = chk(ans, query(x << 1, l, mid, ql, qr));
        if (qr > mid)
            ans = chk(ans, query(x << 1 | 1, mid + 1, r, ql, qr));
        return ans;
    }
    void insert(int x, int l, int r, int p, ll v) {
        if (l == r) {
            val[x] = chk(v, val[x]);
            return;
        }
        int mid = (l + r) >> 1;
        if (p <= mid)
            insert(x << 1, l, mid, p, v);
        if (p > mid)
            insert(x << 1 | 1, mid + 1, r, p, v);
        pushup(x);
    }
};
Seg<greater<ll>, 0> seg;
void dfs1(int u) {
    for (int v : G[u]) {
        if (v == fa[u])
            continue;
        dfs1(v);
        s[u] += f[v];
    }
    for (Line l : ls[u]) {
        ll v = bit.ask(dfn[l.u]) + bit.ask(dfn[l.v]) - bit.ask(dfn[u]) - bit.ask(dfn[fa[u]]);
        f[u] = max(f[u], v + s[u] + l.w);
    }
    bit.radd(dfn[u], dfn[u] + siz[u] - 1, s[u] - f[u]);
}
void dfs2(int u) {
    sr[u] = sr[fa[u]] + s[u] - f[u];
    for (int v : G[u])
        if (v != fa[u])
            dfs2(v);
}
void dfs3(int u) {
    for (int v : G[u]) {
        if (v == fa[u])
            continue;
        g[v] = max(g[v], seg.query(1, 1, n, dfn[u], dfn[v] - 1) - f[v]);
        if (dfn[v] + siz[v] != dfn[u] + siz[u])
            g[v] = max(g[v], seg.query(1, 1, n, dfn[v] + siz[v], dfn[u] + siz[u] - 1) - f[v]);
    }
    vector<pair<ll, pii> > cannot;
    for (Line l : ls[u]) {
        ll v = sr[l.u] + sr[l.v] - sr[u] - sr[fa[u]] + f[u] + g[u] + l.w;
        seg.insert(1, 1, n, dfn[l.u], v);
        seg.insert(1, 1, n, dfn[l.v], v);
        int a = jump(l.u, u), b = jump(l.v, u);
        cannot.push_back({v, {a, b}});
    }
    sort(cannot.begin(), cannot.end(), greater<pair<ll, pii> >());
    list<int> l;
    for (int v : G[u])
        if (v != fa[u])
            l.push_back(v);
    for (auto p : cannot) {
        for (auto it = l.begin(), nt = l.begin(); it != l.end(); it = nt) {
            if (nt != l.end())
                nt++;
            int v = *it;
            if (v != p.second.first && v != p.second.second) {
                g[v] = max(g[v], p.first - f[v]);
                l.erase(it);
            }
        }
        if (l.empty())
            break;
    }
    for (int v : G[u])
        if (v != fa[u])
            dfs3(v);
}
int keys[N], kcnt;
bool cmp(int a, int b) {
    return dfn[a] < dfn[b];
}
inline ll calc(int u, int v) {
    // cout<<u<<" "<<v<<" "<<(sr[v] - sr[u] - (s[v] - f[v]))<<endl;
    return (sr[v] - sr[u] - (s[v] - f[v]));
}
int stk[N];
ll query() {
    sort(keys + 1, keys + 1 + kcnt, cmp);
    kcnt = unique(keys + 1, keys + 1 + kcnt) - keys - 1;
    int top=0;
    int anc = lca(keys[1], keys[kcnt]);
    stk[++top]=anc;
#define ed (stk.size() - 1)
    ll tmp = s[anc] + g[anc];
    for (int i = 1; i <= kcnt; i++) {
        if (keys[i] == anc)
            continue;
        int u = keys[i], v = stk[top], l = lca(u, v);
        if (l != v) {
            while (top > 1 && dfn[stk[top - 1]] > dfn[l]) {
                tmp += calc(stk[top - 1], stk[top]);
                top--;
            }
            if (stk[top - 1] != l) {
                tmp += calc(l, stk[top]);
                tmp += s[l] - f[l];
                stk[top]=l;
            } else {
                tmp += calc(stk[top - 1], stk[top]);
                top--;
            }
        }
        stk[++top]=u;
        tmp += s[u] - f[u];
    }
    while (top > 1)
        tmp += calc(stk[top - 1], stk[top]), top--;
    ll ans = f[1] - tmp + 1;
    return ans;
}
signed main() {
    freopen("flexibility.in", "r", stdin);
    freopen("flexibility.out", "w", stdout);
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int m, q;
    cin >> n >> m >> q;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    pre(1, 0);
    dfs0(1,1);
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        ls[lca(u, v)].push_back({u, v, w});
    }
    for (int i = 1; i <= n; i++)
        ls[i].push_back({i, i, 0});
    dfs1(1);
    dfs2(1);
    dfs3(1);
    ll lans = 0;
    // for(int i=1;i<=n;i++)cout<<g[i]<<" ";
    // cout<<endl;
    for (int i = 1; i <= q; i++) {
        cin >> kcnt;
        for (int j = 1; j <= kcnt; j++)
            cin >> keys[j];
        keys[1] = (keys[1] + lans - 1) % n + 1;
        lans = query();
        cout << lans << endl;
    }

    return 0;
}
```

## USACO2020 铂金

剩下的大黑题要不鸽了吧!

### A. Non-Decreasing Subsequences

值域很小?

可以写成dp,预处理前缀矩阵和矩阵逆的乘积,$(n+q)k^3$.

考虑矩阵长什么样:$f_{i,a_i}=\sum f_{i-1,k},k<a_i$,哦所以矩阵的样子是对角线全是$1$加上第$k$列有一些$1$,那其实乘上这个矩阵是$n^2$的,因为你只需要对每个$1$贡献就行了.

然后求答案的时候向量乘矩阵也是$n^2$的.

### B. Falling Portals

画出每个地方关于时间的纵坐标图像,容易想到对着出发点分类,考虑如果出发点比目的地高,那你就要尽量快的下降,也就是每次走到比自己下的快的直线就下的策略.于是你走的一定是一个凸壳.同时,每条直线转移到的下一跳直线是唯一的,考虑$l$如果在$0$时进入转移到$p$,那么如果它可以从$q\to l$时不走$p$而走$q$只能因为$p$与$l$的交点在$q$与$l$交点之前,但此时根据斜率关系,发现$p$与$q$交点一定在$p$与$l$之前,于是每条直线的转移时唯一的,预处理后倍增的跳即可.

### C. Delegation

难蚌,读成了每个点在一个路径里.(不看样例的吗!)

直接multiset去把里面的都匹配起来传一个剩下的上去.那应该把哪一个放上去是需要考虑的,考虑如果自己这层全都匹配了放上去的是$1$是最不好的,所以如果可以就不要全部匹配,如果当前点有偶数个儿子(可能全部匹配),那么因为全部自己匹配是最劣的所以如果可以先把最大的能放走的的单独放走.如果是奇数那么不可能全部匹配直接做就行了.

### D. Help Yourself

设$f_i$表示最后所有线段的并的右端点是$i$的答案,此时的困难是,如果用区间$[l,r]$转移,对于$i\ge l$我们不会做:新的区间可能会覆盖两个原区间,使得$f_i$中两个连通块合并成一个.此时考虑钦点一个转移顺序避免这种情况,如果出现合并,一定与其中至少一个区间有交,那么考虑按$l$从小到大转移,此时可以做了,对于区间$[l,r]$,所有$f_i,i<l$都要连通块数加$1$贡献过来,$i\in [l,r]$直接贡献过来,$f_i,i>r$无影响(方案数乘$2$).那么线段树维护即可,次幂用斯特林数转组合数.

### E. Sprinklers 2: Return of the Alfalfa

容易发现这些中间只有一条分割线,分割线转角处要放洒水器,好像接下来直接dp,设$f_{i,j,0/1}$表示在$i,j$处放一个洒水器,分割线最后一次方向,每次可以由往上或往左一条线求和转移过来.

### F. Exercise

好厉害的容斥数数.

首先它肯定是让你求所有环的$lcm$的积.那你肯定要转成求指数,又因为直接求指数不好求,考虑算有多少种方案$lcm$是$p^k$的幂,$p$为质数.

考虑怎么在已有若干个环长$n$的排列数上在添加一个长$i$的环,那么这$i$个数自己有$(i-1)!$种,再拼进去有$\binom{n}{i}$种.

考虑先枚举一个$p^k=D$,那么是算有多少种方案包含一个大小为$D$的倍数的环,但包含太难算了考虑变成不包含的排列数$f_n$,但只用不包含的环大小去背包是$n^2$的,考虑再次容斥计算仅有$D$的倍数构成的排列数$g_n$,因为这样的$g$只有$\dfrac{n}{D}$个,然后容斥出$f_n=n!-\sum_i \binom{n}{i}f_ig_{n-i}$(总数减去包含的),同时发现$f$也只有$\dfrac{n}{D}$个,因为你要算$f_n$的时候只用到$f_i,i=n-kD$,再往下递归也始终是这个形式,于是复杂度成了$\dfrac{n^2}{d^2}$,而$\sum \dfrac{1}{d^2}$是收敛的!

最后按照之前写的拼接方式计算$g$,枚举包含第一个点的环长$i$,则方案数是$g_n=g_{n-i}\binom{n-1}{i-1}(i-1)!$.

### G. Circus

### H. Sleeping Cows

上来先对$a,b$排序,这个题$a$和$b$匹配是对称的,考虑从$b$这一维做,则能匹配$b_i$的$a$是一个前缀$p_i$,那么当前这个$b$可以匹配一个$a$,也可以留空,留空要求前面没有必须留空的$a$,于是可以设$f_{i,j,0/1}$表示前$i$个$b$,$1\ldots p_i$中有$j$个$a$还没匹配但该匹配,是否有被钦定不匹配的$a$,每次转移枚举这$[p_i-p_{i-1}]$中的牛有多少加入匹配即可.注意这里$\sum p_i-p_{i-1}=n$所以复杂度其实是$n^2$而不是$n^3$

更好的做法可能是把$a$和$b$一起排序,一次只转移一个.

### I. Spaceship

见鬼生成函数,见鬼多项式,怎么着等NOIP后再补吧

### J. Cowmistry