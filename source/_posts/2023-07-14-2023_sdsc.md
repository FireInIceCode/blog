---
layout: post
title: 2023SDSC
subtitle: 重游山外
tags: 
- 笔记
- 日志
- 集训
- 咕咕
top: 0
show: false
---

## Day0

垃圾山外宿舍6人

## Day1

### Contest

#### T1 colour

> 有序列$a_n$,初始$a_i=0$,给定$p_m$,$q$次询问按顺序遍历$p_l\ldots p_r$,对于$p_i$,选择给$a_{p_i}$或$a_{p_i+1}$赋值为$i$.
> $n\le 500,m\le 10^6,q\le 2000$

对于位置$i$,有一些是和右边选一个赋值,有些是和左边,称为向左伸/向右伸.考虑每个位置最终颜色,注意到$i-1$中向右伸的最高的$lt$是重要的,如果$i-1$的位置最终颜色比$lt$小,则右边必须选的比$lt$大,然后就想到$f_{i,0/1/2}$表示位置$i$选的数与从$i$向右伸的最后一次操作$t$小于/相等/大于就能转移了.

复杂度$nq\log m+m$

#### T2 binary

> ![picture 0](/img/2023-07-14-13-59-22-image.png)  
> 
> $n,m\le 5\times 10^5$

考虑已经选定了$w$之后,答案只在某一次没有$x$或没有$y$才变化,很难注意到左右其实是独立的,因为加入操作左边再操作右边,你操作右边时的$x$一定会找到刚才操作左边的操作位置的右边.

于是只考虑一边,那么相当于给每个$t=1$的操作位置配一个$s=1$的,相当于括号匹配,于是$t=1$,$s=1$分别赋值$1,-1$,然后求失配数,所以直接线段树求最大前缀和/后缀和.

现在对于给定的$w$是1log算.发现$w$是单调的,满足条件的一定是一个后缀,因为$w$往后了你的$u$就不断往前然后后面就越不可能填满前面就越可能填满这样的.

于是二分2log,考虑在刚才的线段树上二分,但$mid$处不一定$t=1$,一种方法是$mid$前后第一个$t=1$的$w_1,w_2$,.但其实可以直接把中间当成可以二分的地方,因为$w_1,w_2$里一定有一个可以把答案拆成$[1,w_1],[w_2,n]$算.

#### T3 tree

> 给定$n$点带权无根树,$q$次询问对于给定的$u,v,A,B$,从$u,v$出发的不交路径$l_1,l_2$,最大的$A\cdot f(l_1)+B\cdot f(l_2)$,其中$f(l)$表示边权和.
> 
> $n\le 5\times 10^5,q\le 10^5$

容易想到可以用$u\to v$上一条边分开树,两个路径分别在一边.然后答案就是两边的距离最大值.

距离最大值可以再拆开,对于$u\to x\to m$,其中$x$在$u\to v$上,$m$在$x$的子树中,变成$dis(u,x)+dis(x,m)$.

树剖之后这个$dis(x,m)$可以预处理,因为虽然它和所在链有关,但是因为树剖之后只有$\log n$个点所在的链不是重链,这些单独处理即可.

然后继续拆贡献,考虑$u,v$为祖孙的情况,$dis(u,x)$差分成两个深度相减,最后去掉只和$u,v$相关的东西就成了$Ag_u(x)+Bg_v(y)$,其中$g_u(x)=l_x-dep_x,g_v(x)=l_x+dep_x$这样的状物.

然后考虑这树剖后线段树对应的$\log^2 n$个区间,考虑$x$和$y$的位置,他们要满足$x<y$.如果他们所在的拆出的线段树区间不同可以直接做(枚举一个区间,算另一边最小值),另一种情况考虑它们所在的区间相同,此时考虑那个用一条边分开树,那么枚举这个区间中的分界线,此时两边贡献就是一个前缀/后缀max,正反各扫一遍可以获得,然后线性建凸壳.这样建树就2log(每个区间跑一遍凸壳).询问可以排个序砍掉在凸壳上二分的log.

法2是淀粉质

询问被拆成从分治重心出发的两部分,仍然拆贡献,然后直接从重心dfs,维护凸包,每进入一个点插入到凸包中,退出一个点再撤销,所以凸包要李超树,复杂度是查询2log预处理1log.

得分100 + 0 + 15,没打T2暴力大大失败

### Class

#### CF1764G3 Doremy's Perfect DS Class (Hard Version)

> - **这是一道交互题。**
> - 交互库有一个 $[1,n]$ 的排列 $p$。
> - 你可以询问 $l,r,k$，交互库会返回 $\left\lfloor\dfrac{p_l}k\right\rfloor,\left\lfloor\dfrac{p_{l+1}}k\right\rfloor,\cdots,\left\lfloor\dfrac{p_r}k\right\rfloor$ 中不同数的个数。
> - 你需要在 $20$ 次询问内找到 $p$ 中 $1$ 的位置。
> - $n\in[3,1024]$。

$n$为奇数时,考虑让$k=2$,因为除以$k$相等的数两两配对.这样问前缀$[1,i]$得到$t$,那么$2t-i$就是出现恰好一次的,再同样的问一下另一边,那么$1$就在多的那一边.复杂度$2\log n$

$n$为偶数时,除了$1$,$n$也没有配对,问完之后如果两边恰好一次的一样多显然就$1$,$n$各一个,然后问一遍$n$就能找到谁是$n$,以后就不用再问了($n$已经在区间外了),次数$2\log n+1$

考虑如何把$+1$砍了,那么看起来考虑最后一次长为$2$的时候,假设当前为$p,p+1$,则因为二分成了这个区间,一定已经知道$[1,p-1],[1,p+1],[p+2,n],[p,n]$这些区间,那么考虑$[1,p-1]$和$[1,p+1]$,它们中间增加了一个$1$和一个$p$通过看种类数加2还是加1就可以判断这两个数中除了$1$,另一个数的配对出现在哪一边,假设在后缀,然后再问$[p+1,n]$,判断种类数是否增加,这样就把数量减少到$20$次.

#### luogu P9393 紫丁香

> 对于一个字符串 $A$，记 $A_i$ 表示它的第 $i$ 个字符。
> 
> 设 $S$ 是任意长度为 $m$ 的 $01$ 串。我们有 $n$ 个操作，第 $i$ 个操作可以表示成一个定义域和值域都是长度为 $m$ 的 $01$ 串集合的函数 $f_i$，表示经过这次操作后 $S$ 会变成 $f_i(S)$。而函数 $f_i$ 可以由一个长度为 $m$ 的串 $T_i$ 表示，$T_i$ 由 $\texttt{0,1,-}$ 三种字符组成，其中：
> 
> - $T_{i,j}=\texttt{0}$ 表示 $[f_i(S)]_j=\texttt{0}$。
> 
> - $T_{i,j}=\texttt{1}$ 表示 $[f_i(S)]_j=\texttt{1}$。
> 
> - $T_{i,j}=\texttt{-}$ 表示 $[f_i(S)]_j=S_j$。
> 
> 也就是说，每个操作会将 $S$ 的一些位赋值为 $0$，一些位赋值为 $1$，还有一些位不变。
> 
> 现在有 $q$ 次操作，每次操作给定一个长度为 $m$ 的 $01$ 串 $S$，你可以对它做任意多次操作，操作的顺序任意，一个操作可以做多次。得到的串 $S'$ 可以被看做一个二进制数，求对应二进制数最大的 $S'$。
>
> $m\le 22,n,q\le 10^5$

考虑倒着做,因为正着操作是不可逆的而倒着操作每次操作都会变的更好,那么撤销一次操作后串由$0,1,?$组成,要找到最大的$01?$串可以匹配一开始的$s$.

你发现3进制我们没法用各种子集dp,集合科技,因为存不下$3^n$.

然后注意到因为我们最后要找最大的答案,所以直接把$0$都变成$?$是不劣的,而找到最大的$1?$串之后所有$?$最后一定都是$0$.于是变成$2$进制问题.然后就是要从结果开始不断用操作把$1$消成$?$直到弄不动了,再判断能不能和初始状态匹配.

然后考虑$f_i$表示可以把$i$消去至少一个$1$的操作,一个FWT搞定.然后考虑$g_i$表示$i$可以变成什么,则$g_i=g_{f_i(i)}$就对了吧

最后要处理多组询问,相当于求最大的$g_i\supset s$,也是一遍dp.

#### CF1693E Outermost Maximums

> 有一个长度为 $n+2$ 的序列 $a$，其中 $a_0=a_{n+1}=0$，其余元素均给定。  
> 你可以进行下面两种操作任意次：
> 
> 1. 设 $x$ 表示序列 $a$ 最靠左的最大值的位置，则令 $a_x\leftarrow \max_{i=0}^{x-1}a_i$。
> 2. 设 $y$ 表示序列 $a$ 最靠右的最大值的位置，则令 $a_y\leftarrow \max_{i=y+1}^{n+1}a_i$。
> 
> 你需要求出使序列 $a$ 的所有元素均变成 $0$ 所需的最少的操作总次数。

考虑一个$n^2$做法,对于当前最大值,找到次大值位置,然后左边的都用操作1右边的都用操作2,中间的随便.

然后考虑优化,因为不能实时维护最大值次大值,考虑每个数放一个箭头表示它是由操作$1$(左箭头)或操作$2$(右箭头)得到,如果当前最大值为$x$,那么左箭头是一个前缀,右箭头是一个后缀,不会有两个箭头相对,一串箭头指向一个$x$这一串都是$x$.那么这一次操作只需要定位当前次大值,算出新的分界线(不一定是次大值,还可能是某个箭头).

#### CF1209G2 Into Blocks (hard version)

> 给你 $n$ , $q$，$n$ 表示序列长度，$q$ 表示操作次数。
> 
> 我们需要达成这么一个目标状态：
> 如果存在 $x$ 这个元素，那么必须满足所有 $x$ 元素都必须在序列中连续。
> 
> 然后你可以进行这么一种操作，将所有的 $x$ 元素的变为任意你指定的 $y$ 元素，并且花费 $cnt[x]$ 的花费，$cnt[x]$ 代表 $x$ 元素的个数。
> 
> 现在有 $q$ 次询问，每次询问单点修改一个位置的值，求修改完之后最小花费使得序列满足目标状态。
> 
> 注意：更新不是独立的，之前的更新会保留。
>
> $n,q\le 2\times 10^5$

考虑合并到最后一定是若干段,但合并是困难的,所以改成考虑没有被同一个值覆盖的是分界线.

然后线段树维护,分界线作为被覆盖次数最小的位置,另外区间众数因为所有数都在一个区间里所以就是区间max.

#### CF1656G Cycle Palindrome

>  给定一个长度为 $n$ 的数列 $a_{1 \cdots n}$，你需要找到一个**循环数列** $b_{1 \cdots n}$ 使得数列 $\{ a_{b_{1}},a_{b_{2}},a_{b_{3}}, \cdots,a_{b_{n}} \}$ 是一个**回文数列**且 $b$ 是一个长度为 $n$ 的**排列**。
> 
> \sum n\le 2\times 10^5


因为循环排列很困难,所以考虑随便构造一个回文串然后调整成这个

首先如果$a_i=a_j$,$i,j$不在一个环上显然$i$和$j$交换合并两个环.

然后现在所有相对位置都在一个环上.

考虑两对$a_i=a_j,a_k=a_l$,那么按顺序交换$i,k$,$j,l$,$i,j$的出边交换.

#### uoj783 新年的双区间操作

> 给定$a_n$和$m$个操作$(l,r,x,l',r',y)$,表示如果区间$[l,r]$中最大值大于$x$,就让区间$[l',r']$中每个数和$y$取max,接下来有$q$次单点修改,在每次修改后求出进行所有操作后序列的最大值为多少.
> 
> $n,m\le 2\times 10^5,q\le 6\times 10^5$,4s

考虑每个操作可以写成如果被触发,答案对$f_i$取max,于是如果求出$f$只要考虑初始位置和修改贡献,简单题.

那么问题就成了如何求$f$,那就是对每个区间找有哪些区间与自己有交,自己的$f$,且$x$比自己$y$小,且时间比自己晚,对这些区间的$f$取个max,就是个偏序dp.大概扫时间,cdq值域,线段树维护序列维.
