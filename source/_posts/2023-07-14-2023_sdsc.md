---
layout: post
title: 2023SDSC
subtitle: 重游山外
tags: 
- 笔记
- 日志
- 集训
- 咕咕
top: 0
show: false
---

## Day0

垃圾山外宿舍6人

## Day1

### Contest

#### T1 colour

> 有序列$a_n$,初始$a_i=0$,给定$p_m$,$q$次询问按顺序遍历$p_l\ldots p_r$,对于$p_i$,选择给$a_{p_i}$或$a_{p_i+1}$赋值为$i$.
> $n\le 500,m\le 10^6,q\le 2000$

对于位置$i$,有一些是和右边选一个赋值,有些是和左边,称为向左伸/向右伸.考虑每个位置最终颜色,注意到$i-1$中向右伸的最高的$lt$是重要的,如果$i-1$的位置最终颜色比$lt$小,则右边必须选的比$lt$大,然后就想到$f_{i,0/1/2}$表示位置$i$选的数与从$i$向右伸的最后一次操作$t$小于/相等/大于就能转移了.

复杂度$nq\log m+m$

#### T2 binary

> ![picture 0](/img/2023-07-14-13-59-22-image.png)  
> 
> $n,m\le 5\times 10^5$

考虑已经选定了$w$之后,答案只在某一次没有$x$或没有$y$才变化,很难注意到左右其实是独立的,因为加入操作左边再操作右边,你操作右边时的$x$一定会找到刚才操作左边的操作位置的右边.

于是只考虑一边,那么相当于给每个$t=1$的操作位置配一个$s=1$的,相当于括号匹配,于是$t=1$,$s=1$分别赋值$1,-1$,然后求失配数,所以直接线段树求最大前缀和/后缀和.

现在对于给定的$w$是1log算.发现$w$是单调的,满足条件的一定是一个后缀,因为$w$往后了你的$u$就不断往前然后后面就越不可能填满前面就越可能填满这样的.

于是二分2log,考虑在刚才的线段树上二分,但$mid$处不一定$t=1$,一种方法是$mid$前后第一个$t=1$的$w_1,w_2$,.但其实可以直接把中间当成可以二分的地方,因为$w_1,w_2$里一定有一个可以把答案拆成$[1,w_1],[w_2,n]$算.

#### T3 tree

> 给定$n$点带权无根树,$q$次询问对于给定的$u,v,A,B$,从$u,v$出发的不交路径$l_1,l_2$,最大的$A\cdot f(l_1)+B\cdot f(l_2)$,其中$f(l)$表示边权和.
> 
> $n\le 5\times 10^5,q\le 10^5$

容易想到可以用$u\to v$上一条边分开树,两个路径分别在一边.然后答案就是两边的距离最大值.

距离最大值可以再拆开,对于$u\to x\to m$,其中$x$在$u\to v$上,$m$在$x$的子树中,变成$dis(u,x)+dis(x,m)$.

树剖之后这个$dis(x,m)$可以预处理,因为虽然它和所在链有关,但是因为树剖之后只有$\log n$个点所在的链不是重链,这些单独处理即可.

然后继续拆贡献,考虑$u,v$为祖孙的情况,$dis(u,x)$差分成两个深度相减,最后去掉只和$u,v$相关的东西就成了$Ag_u(x)+Bg_v(y)$,其中$g_u(x)=l_x-dep_x,g_v(x)=l_x+dep_x$这样的状物.

然后考虑这树剖后线段树对应的$\log^2 n$个区间,考虑$x$和$y$的位置,他们要满足$x<y$.如果他们所在的拆出的线段树区间不同可以直接做(枚举一个区间,算另一边最小值),另一种情况考虑它们所在的区间相同,此时考虑那个用一条边分开树,那么枚举这个区间中的分界线,此时两边贡献就是一个前缀/后缀max,正反各扫一遍可以获得,然后线性建凸壳.这样建树就2log(每个区间跑一遍凸壳).询问可以排个序砍掉在凸壳上二分的log.

法2是淀粉质

询问被拆成从分治重心出发的两部分,仍然拆贡献,然后直接从重心dfs,维护凸包,每进入一个点插入到凸包中,退出一个点再撤销,所以凸包要李超树,复杂度是查询2log预处理1log.

得分100 + 0 + 15,没打T2暴力大大失败

### Class

#### CF1764G3 Doremy's Perfect DS Class (Hard Version)

> - **这是一道交互题。**
> - 交互库有一个 $[1,n]$ 的排列 $p$。
> - 你可以询问 $l,r,k$，交互库会返回 $\left\lfloor\dfrac{p_l}k\right\rfloor,\left\lfloor\dfrac{p_{l+1}}k\right\rfloor,\cdots,\left\lfloor\dfrac{p_r}k\right\rfloor$ 中不同数的个数。
> - 你需要在 $20$ 次询问内找到 $p$ 中 $1$ 的位置。
> - $n\in[3,1024]$。

$n$为奇数时,考虑让$k=2$,因为除以$k$相等的数两两配对.这样问前缀$[1,i]$得到$t$,那么$2t-i$就是出现恰好一次的,再同样的问一下另一边,那么$1$就在多的那一边.复杂度$2\log n$

$n$为偶数时,除了$1$,$n$也没有配对,问完之后如果两边恰好一次的一样多显然就$1$,$n$各一个,然后问一遍$n$就能找到谁是$n$,以后就不用再问了($n$已经在区间外了),次数$2\log n+1$

考虑如何把$+1$砍了,那么看起来考虑最后一次长为$2$的时候,假设当前为$p,p+1$,则因为二分成了这个区间,一定已经知道$[1,p-1],[1,p+1],[p+2,n],[p,n]$这些区间,那么考虑$[1,p-1]$和$[1,p+1]$,它们中间增加了一个$1$和一个$p$通过看种类数加2还是加1就可以判断这两个数中除了$1$,另一个数的配对出现在哪一边,假设在后缀,然后再问$[p+1,n]$,判断种类数是否增加,这样就把数量减少到$20$次.

#### luogu P9393 紫丁香

> 对于一个字符串 $A$，记 $A_i$ 表示它的第 $i$ 个字符。
> 
> 设 $S$ 是任意长度为 $m$ 的 $01$ 串。我们有 $n$ 个操作，第 $i$ 个操作可以表示成一个定义域和值域都是长度为 $m$ 的 $01$ 串集合的函数 $f_i$，表示经过这次操作后 $S$ 会变成 $f_i(S)$。而函数 $f_i$ 可以由一个长度为 $m$ 的串 $T_i$ 表示，$T_i$ 由 $\texttt{0,1,-}$ 三种字符组成，其中：
> 
> - $T_{i,j}=\texttt{0}$ 表示 $[f_i(S)]_j=\texttt{0}$。
> 
> - $T_{i,j}=\texttt{1}$ 表示 $[f_i(S)]_j=\texttt{1}$。
> 
> - $T_{i,j}=\texttt{-}$ 表示 $[f_i(S)]_j=S_j$。
> 
> 也就是说，每个操作会将 $S$ 的一些位赋值为 $0$，一些位赋值为 $1$，还有一些位不变。
> 
> 现在有 $q$ 次操作，每次操作给定一个长度为 $m$ 的 $01$ 串 $S$，你可以对它做任意多次操作，操作的顺序任意，一个操作可以做多次。得到的串 $S'$ 可以被看做一个二进制数，求对应二进制数最大的 $S'$。
>
> $m\le 22,n,q\le 10^5$

考虑倒着做,因为正着操作是不可逆的而倒着操作每次操作都会变的更好,那么撤销一次操作后串由$0,1,?$组成,要找到最大的$01?$串可以匹配一开始的$s$.

你发现3进制我们没法用各种子集dp,集合科技,因为存不下$3^n$.

然后注意到因为我们最后要找最大的答案,所以直接把$0$都变成$?$是不劣的,而找到最大的$1?$串之后所有$?$最后一定都是$0$.于是变成$2$进制问题.然后就是要从结果开始不断用操作把$1$消成$?$直到弄不动了,再判断能不能和初始状态匹配.

然后考虑$f_i$表示可以把$i$消去至少一个$1$的操作,一个FWT搞定.然后考虑$g_i$表示$i$可以变成什么,则$g_i=g_{f_i(i)}$就对了吧

最后要处理多组询问,相当于求最大的$g_i\supset s$,也是一遍dp.

#### CF1693E Outermost Maximums

> 有一个长度为 $n+2$ 的序列 $a$，其中 $a_0=a_{n+1}=0$，其余元素均给定。  
> 你可以进行下面两种操作任意次：
> 
> 1. 设 $x$ 表示序列 $a$ 最靠左的最大值的位置，则令 $a_x\leftarrow \max_{i=0}^{x-1}a_i$。
> 2. 设 $y$ 表示序列 $a$ 最靠右的最大值的位置，则令 $a_y\leftarrow \max_{i=y+1}^{n+1}a_i$。
> 
> 你需要求出使序列 $a$ 的所有元素均变成 $0$ 所需的最少的操作总次数。

考虑一个$n^2$做法,对于当前最大值,找到次大值位置,然后左边的都用操作1右边的都用操作2,中间的随便.

然后考虑优化,因为不能实时维护最大值次大值,考虑每个数放一个箭头表示它是由操作$1$(左箭头)或操作$2$(右箭头)得到,如果当前最大值为$x$,那么左箭头是一个前缀,右箭头是一个后缀,不会有两个箭头相对,一串箭头指向一个$x$这一串都是$x$.那么这一次操作只需要定位当前次大值,算出新的分界线(不一定是次大值,还可能是某个箭头).

#### CF1209G2 Into Blocks (hard version)

> 给你 $n$ , $q$，$n$ 表示序列长度，$q$ 表示操作次数。
> 
> 我们需要达成这么一个目标状态：
> 如果存在 $x$ 这个元素，那么必须满足所有 $x$ 元素都必须在序列中连续。
> 
> 然后你可以进行这么一种操作，将所有的 $x$ 元素的变为任意你指定的 $y$ 元素，并且花费 $cnt[x]$ 的花费，$cnt[x]$ 代表 $x$ 元素的个数。
> 
> 现在有 $q$ 次询问，每次询问单点修改一个位置的值，求修改完之后最小花费使得序列满足目标状态。
> 
> 注意：更新不是独立的，之前的更新会保留。
>
> $n,q\le 2\times 10^5$

考虑合并到最后一定是若干段,但合并是困难的,所以改成考虑没有被同一个值覆盖的是分界线.

然后线段树维护,分界线作为被覆盖次数最小的位置,另外区间众数因为所有数都在一个区间里所以就是区间max.

#### CF1656G Cycle Palindrome

>  给定一个长度为 $n$ 的数列 $a_{1 \cdots n}$，你需要找到一个**循环数列** $b_{1 \cdots n}$ 使得数列 $\{ a_{b_{1}},a_{b_{2}},a_{b_{3}}, \cdots,a_{b_{n}} \}$ 是一个**回文数列**且 $b$ 是一个长度为 $n$ 的**排列**。
> 
> \sum n\le 2\times 10^5


因为循环排列很困难,所以考虑随便构造一个回文串然后调整成这个

首先如果$a_i=a_j$,$i,j$不在一个环上显然$i$和$j$交换合并两个环.

然后现在所有相对位置都在一个环上.

考虑两对$a_i=a_j,a_k=a_l$,那么按顺序交换$i,k$,$j,l$,$i,j$的出边交换.

#### uoj783 新年的双区间操作

> 给定$a_n$和$m$个操作$(l,r,x,l',r',y)$,表示如果区间$[l,r]$中最大值大于$x$,就让区间$[l',r']$中每个数和$y$取max,接下来有$q$次单点修改,在每次修改后求出进行所有操作后序列的最大值为多少.
> 
> $n,m\le 2\times 10^5,q\le 6\times 10^5$,4s

考虑每个操作可以写成如果被触发,答案对$f_i$取max,于是如果求出$f$只要考虑初始位置和修改贡献,简单题.

那么问题就成了如何求$f$,那就是对每个区间找有哪些区间与自己有交,自己的$f$,且$x$比自己$y$小,且时间比自己晚,对这些区间的$f$取个max,就是个偏序dp.大概扫时间,cdq值域,线段树维护序列维.

## Day2

### Contest

#### T1

> 给定$a_n$,$q$次区间询问$[l,r]$最多可以选出多少个不交的和为$0$的区间.
> $n,q\le 4\times 10^5$,32M

先以每个点为左端点匹配出和为$0$的区间,然后每个点找到右端点最左的左端点在它右边的点,于是询问就是不断跳这个.

倍增空间炸了,写个树剖即可.

然后更强的方法是在得到的树上算出深度,从询问左右端点分别向右找到第一个区间算出深度,它们的深度差是答案或答案差$1$,于是离线树上$k$级祖先可以做到时间空间线性.

#### T2

> 给定$n$点树,求一条链$u\to v$最大化$dis(u,v)\cdot f(u,v)$,其中$f(u,v)$表示最大的树上点到它的距离.
> $n\le 5\times 10^5$

这个信息很全局,不要淀粉质.

考虑这个结构其实是一个树上的三叉,枚举三叉中心也就是那个离链最远的点连到链上得到的那个点$r$,此时$u,v$和最远点$w$分别在一个子树,那么答案一定是这三个子树中最远的叶子搞出来的.

然后计数就直接一次换根dp算最远叶子及叶子个数.

然后这个会让人产生一个问题就是你可能枚举两个$r$对应同一组$u,v$,那么情况就是选出一组$u,v$,然后链的不同部分可以连出两个长度相等的$w$.

![picture 2](/img/2023-07-15-15-22-21-image.png)  

然后你发现一个$u/v$换到$w$一定会严格更大,于是直接在每个$r$上计数就不会重.


#### T3

> ![picture 1](/img/2023-07-15-14-55-14-image.png)  
>
> $n\le 18$

杜赢说你随机调整后打表可以过16.

考虑把所有$2^n$种状态建图成点,人的策略作为边,因为人无法区分$x,y$如果$x,y$只有自己所在位不同,则把$x,y$连一条边,这条边就表示如果判断出局面是$x,y$之中,那么它选择谁,那么问题就成了要给所有边定向满足任意一个点有不少于一半的边指向自己,于是直接跑欧拉回路使得每个点的度数正好是对的.

### Class

#### Swapping Operation

> 给定$a_n$,定义$f(a)=\max_k \operatorname{and}_{i\le k} a_i +\operatorname{and}_{i>k} a_i$,你可以进行至多一次交换两个数,求之后的最大值.

你先把原答案暴力出来,那么众所周知and只变化log次,两边各有log个,如果不换这些则答案一定只会变小.把这些点称作关键点.

交换两个关键点之间暴力.

于是问题是交换一个关键点和一个非关键点,假设把前缀的关键点换走了,那么后缀的部分和换走了谁没关系,先枚举分界线,再枚举换走的东西,最后就成了最大化$f(1,i-1)\&f(i+1,k)\& a_j$然后因为两个$f$的值只有log种,于是一共只有$\log^2$种,直接对每一种,算出$g(v,k)$表示$k+1\le j\le n$表示与$v$亦或之后的最大值.

要用st表优化求and和.复杂度2log.

#### Pair

> 平面上$2n$个点,两两匹配,最大化好的匹配个数,好的匹配定义为点在同一行或同一列.

考虑网格图网络流建模每个横坐标建点每个纵坐标建点,原来的点变成行列之间的边.

此时就是有公共点的边之间是好的匹配,上界显然是每个连通块$\lfloor \dfrac{siz}{2} \rfloor$,而这个是可以达到的,只要把连通块拉成dfs树,然后从下往上,每个点都匹配完了或留一条父边就能构造出来了.

复杂度线性.

#### Be Careful $2$

> $n\times m$的矩形有$k$个特殊点,一个正方形是好的当且仅当完全位于矩形内且不覆盖任意一个特殊点,求好的正方形面积之和.
> 做到$k^2$

先容斥算对覆盖$S$所有点的方案数.

那么子集有$2^k$个但点集包围盒只有$k^4$个.

然后发现如果包围盒内部有点则容斥系数是$0$,因为每个点在/不在就让系数消了,只考虑所有点都在边界上的$k^2$个

然后考虑如何找到所有包围盒,考虑先枚举矩形左边界上的一个点,再枚举矩形右边界上的一个点,那么两个点为对角围成的矩形之间肯定没点,那么所有的右端点是单调的,同时上下边就是对应的这横坐标两个点之间,纵坐标前驱后继的点.于是单调栈维护右端点,再用链表维护每个横坐标下所有点的前驱后继.

然后要统计答案,对每个答案贡献是一个分段四次函数,直接再做前缀和结束了.

复杂度$k^2$

#### Mystery Square

> ![picture 6](/img/2023-07-15-19-56-52-image.png)  

先从中间拆成两半,考虑只有20个问号的一边.
todo

#### 回

> ![picture 4](/img/2023-07-15-19-56-12-image.png)  

cdq分治让操作都在询问前 + 差分 + 维护关于原始数组的高次多项式

操作二维差分只会变成了主对角线副对角线加,然后再差分成射线加,再差分成一个点和一个方向.

然后维护奇妙而复杂的多项式,找网上题解吧.

#### Difficult Constructive Problem

> ![picture 5](/img/2023-07-15-19-56-37-image.png)  


暴力枚举头尾的问号,现在假设头尾已经确定.

然后发现翻转字符只改变2,不改变奇偶性,并且是连续的,直接从前向后贪心,每个位置看如果填了$0$后面的能不能行

#### Permutation Arrangement

先假设所有问号不相邻,那么问题是匹配,于是一个数最多只有四个空不能放,于是当$n\ge 8$的时候,每个点至少连出$4$条,Hall定理发现是一定有解.

于是现在有空位了,那么把空位随便填,留出8个不相邻的,于是如果有至少15个空一定有解///xia

于是前面随便填,最后15个状压爆搜.

#### workshop

> ![picture 3](/img/2023-07-15-19-29-30-image.jpg)  
>
> 数字最后要到$2$

因为一开始是排列,所以考虑不断利用初始序列压缩初始序列的值域并始终保持互不相同的性质.

那么第一次只知道自己和右边,要求一个函数满足$f(u,v)\ne f(v,w)$,那么一个方法是$u,v$lcp后第一位是几以及lcp长度,值域变成$2\log v$

然后因为中午和晚上能同时看到两边,所以可以做两次,就是$v\to f(f(u,v),f(v,w))$

然后这样的话这个$2$不够优秀,考虑怎么不乘$2$,考虑使用lowbit为长度一半的二进制来编码,那么因为没有两个不同的数互相包含,所以可以直接记录第一个$u=1,v=0$的位置,此时中午结束后答案到$0\ldots 3$

那么为了压成$0\ldots 2$,直接对当前位分类讨论,如果当前位是$0,1,2$不管,如果是$3$,那么两边一定是$0,1,2$中的,所以选剩下的一个就做完了.