---
title: CF
subtitle: CF 
layout: post
show: true
istop: false
tags: 
- 日志
---

## CF1827

### B Range Sorting

> 对一个数组 $\{p_i\}$ 的一段区间 $[l,r]$ 排序的代价为 $r-l$ ，对整个数组 $p_i$ 排序的代价为选定若干区间并排序，使得整个数组有序的代价之和。
> 求 $\{a_i\}$ 的所有子段排序的代价之和。
> $n\le 3\times 10^5$

首先排序区间不交,不然相交的用一个大的代替.

考虑贡献拆分到,没有一个区间覆盖$i,i+1$之间的间隔,等价于$\max p_{l:i}\le \min p_{i+1:r}$,计数$l,r$组数即可

直接枚举间隔+维护单调栈+双指针可以过 B1

考虑一个剪枝,扫$[i+1:]$时若$\min p_{i+1:j}<p_i$则显然可以跳,复杂度可以考虑一个小根笛卡尔树,在后半部分前缀min的单调栈上走相当于身为左儿子跳父亲.

### C Palindrome Partition

> 称一个字符串是好的，当且仅当它是一个长度为偶数的回文串或由若干长度为偶数的回文串拼接而成。
> 
> 给定一个长度为 $n$ 的字符串 $s$，求有多少 $s$ 的子串是好的。
> 
> $1\le n\le5\times10^5$，$s$ 仅包含小写字母。

结论是,每个字符串存在唯一的最小划分.考虑选了一个大的偶回文串,又选了一个小的,那么如果小的长度不超过大的一半的情况是显然的,而可以证明如果存在一个长度超过大的一半的,一定存在一个不超过的:因为回文串,于是一定其中短的是长的border,超过一半长的border对应一个不到一半长的周期,而周期倍数也是周期,所以一定可以扩到一个超过一半的周期对应一个不超过一半的border,所以一定存在.

于是只要每次选最短的长度即可.先一遍求出所有回文串,然后用一个单调栈维护所有中心(关于位置的后缀max)求出以每个位置结尾的最短的回文串,然后一遍dp.

### D Two Centroids

> 给定$n$点树,每次往一个点上挂一个叶子,并询问此时至少加几个点才能让树有两个重心
> 
> $n\le 5\times 10^5$

显然要加几个点才能让树有两个重心,就是找一条边当最后的重心,等价于找到一个点最小化$\vert n-siz_u-siz_u \vert$.

然后这条边实际上和重心十分类似,都是最小化删了之后剩下部分的差,同样分析边的移动可以得到性质,它与重心直接相连,且加一个点边最多朝那个点移动一下.

于是加点时维护当前这条边,维护子树大小即可.

