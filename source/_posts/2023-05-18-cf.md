---
title: CF
subtitle: CF 
layout: post
show: true
istop: false
tags: 
- 日志
---

## CF1827

### B Range Sorting

> 对一个数组 $\{p_i\}$ 的一段区间 $[l, r]$ 排序的代价为 $r-l$ , 对整个数组 $p_i$ 排序的代价为选定若干区间并排序, 使得整个数组有序的代价之和.
> 求 $\{a_i\}$ 的所有子段排序的代价之和.
> $n\le 3\times 10^5$

首先排序区间不交, 不然相交的用一个大的代替.

考虑贡献拆分到, 没有一个区间覆盖 $i, i+1$ 之间的间隔, 等价于 $\max p_{l: i}\le \min p_{i+1: r}$, 计数 $l, r$ 组数即可

直接枚举间隔+维护单调栈+双指针可以过 B1

考虑一个剪枝, 扫 $[i+1: ]$ 时若 $\min p_{i+1: j}<p_i$ 则显然可以跳, 复杂度可以考虑一个小根笛卡尔树, 在后半部分前缀min的单调栈上走相当于身为左儿子跳父亲.

### C Palindrome Partition

> 称一个字符串是好的, 当且仅当它是一个长度为偶数的回文串或由若干长度为偶数的回文串拼接而成.
> 
> 给定一个长度为 $n$ 的字符串 $s$, 求有多少 $s$ 的子串是好的.
> 
> $1\le n\le5\times10^5$, $s$ 仅包含小写字母.

结论是, 每个字符串存在唯一的最小划分. 考虑选了一个大的偶回文串, 又选了一个小的, 那么如果小的长度不超过大的一半的情况是显然的, 而可以证明如果存在一个长度超过大的一半的, 一定存在一个不超过的: 因为回文串, 于是一定其中短的是长的border, 超过一半长的border对应一个不到一半长的周期, 而周期倍数也是周期, 所以一定可以扩到一个超过一半的周期对应一个不超过一半的border, 所以一定存在.

于是只要每次选最短的长度即可. 先一遍求出所有回文串, 然后用一个单调栈维护所有中心(关于位置的后缀max)求出以每个位置结尾的最短的回文串, 然后一遍dp.

### D Two Centroids

> 给定 $n$ 点树, 每次往一个点上挂一个叶子, 并询问此时至少加几个点才能让树有两个重心
> 
> $n\le 5\times 10^5$

显然要加几个点才能让树有两个重心, 就是找一条边当最后的重心, 等价于找到一个点最小化 $\vert n-siz_u-siz_u \vert$.

然后这条边实际上和重心十分类似, 都是最小化删了之后剩下部分的差, 考虑去掉重心得到的连通块中大于一半的那一个和重心的连边即是这条边.

于是加点时维护当前这条边, 维护子树大小即可.

### E Bus Routes

> 给定 $n$ 个点的树和 $m$ 条路径, 求是否任意两个点都可以通过沿着走不超过两条路径的区间到达.
> 
> $n, m\le 5\times 10^5$

骗你一手点分治.

考虑所有叶子节点, 如果它们互相可达那么显然中间的点都可以.

考虑每个叶子找到一条路径内能到达的最浅点, 树合法当且仅当所有最浅点构成一条链.

复杂度 $n\log n$ 

## CF1830

### A. Copil Copac Draws Trees

一眼题

### B. The BOSS Can Count Pairs

根号分治一眼题.

### C. Hyperregular Bracket Strings

> 给定$n,k$和$l_k,r_k$,求有多少个合法括号序列满足$\forall i,[l_i,r_i]$也是合法括号序列.
> 
> $\sum n,\sum k\le 3\times 10^5$

看到括号序列考虑前缀和.设前缀和为$s_n$

考虑如果有两个$l_1\le l_2\le r_1\le r_2$,因为$s_i\ge s_{l}=s_{r},i\in [l,r]$,所以显然$s_{l_1}=s_{l_2}=s_{r_1}=s_{r_2}$,等价于要求三个不交的区间合法.

再考虑如果两个区间是包含的就更好处理了,方案数就是子区间的合法括号方案数乘外面去掉子区间的.

于是一种方案就是直接暴力模拟上面的过程,假设两个相交的区间有边,就是找到连通块拆了,剩下随便做.

官方题解省略了拆分的过程,而是考虑把所有由同一子集的区间覆盖的位置拿出来,每个子集对应的所有位置要构成括号序列.

### D. Mex Tree

> 给定一棵$n$点树,给边赋值$v\in {0,1}$,最大化$\sum_i \sum_j \operatorname{mex}\{k\vert k \in path_{i,j}\}$.
> 
> $n\le 2\times 10^5$

考虑一个暴力dp,$f_{i,j,0/1}$表示如果$i$的父边是$0/1$,$i$子树中有$j$个点到$i$只经过和父边相同颜色的边的情况下,$i$子树内的最大贡献.

转移到$u$时,只要逐个添加儿子,维护前面有多少个点到$u$只经过$0$,多少个只经过$1$即可.复杂度是树形dp的$n^2$

不会做了,猜$j$很小.

考虑$j$就是与$i,fa_i$相连的同色连通块大小.考虑二分染色构造下,$n(n-1)-ans\le 2n$,于是在任何比二分染色优的方案中,对于一个大小为$s$的连通块,$\dfrac{s(s-1)}{2}\le 2n$.也就是说$s\le \sqrt 2n$

胜利,复杂度$n\sqrt n$

### E. Bully Sort

> 给定一个长度为$n$的排列$p$，定义一个“bully swap”操作如下：找到最大元素$p_i$（且$p_i\neq i$），再找到最小的$p_j$（$i<j$），交换$p_i$和$p_j$。定义$f(p)$为通过执行“bully swap”操作将$p$变成有序排列的次数。给定$n$和排列$p$，需要处理$q$个更新操作，每个操作给出两个整数$x$和$y$，交换$p_x$和$p_y$，然后计算新排列$p$的$f(p)$值。注意，更新是持久的，对排列$p$的更改将应用于处理未来的更新。
> 
> $n\le 5\times 10^5,q\le 5\times 10^4$

注意到往左移的应该是一个后缀$\min$,其他的往右走,左右是分开的.

当把一个最大值$i$与后面最小值$j$交换时,逆序对变化为$2(j-i)-1$.考虑此时最小值移动了$j-i$步,而每个最小值一共应该移动$i-p_i$步,那么$2\text{一开始的逆序对}-2\text{\sum_i \vert i-p_i\vert}=ans$

于是问题就是动态维护逆序对了.复杂度$n\log^2 n$

### F. The Third Grace

> 给定一个数轴上的 $n$ 个区间和 $m$ 个点。第 $i$ 个区间覆盖坐标 $[l_i, r_i]$，第 $i$ 个点在坐标 $i$ 处，并且具有系数 $p_i$。
> 
> 最初，所有点都未激活。你需要选择一些点来激活。对于每个区间 $i$，我们定义它的代价为：
> 
> - 若区间内没有被激活的点，则代价为 $0$；
> - 否则，代价为在区间内坐标最大的被激活点的系数。
> 
> 你的任务是通过选择哪些点激活，使得所有区间的代价之和最大。

容易想到dp$f_i$表示最后一个选在$i$,不计算$i$的贡献的情况下的最大价值.转移就是枚举上一个点:$f_i=\max_j f_j + W(i,j)*p_j$,其中$W(l,r)$表示覆盖$l$不覆盖$r$的区间个数.

考虑扫描过程中$w_l$表示$W(l,i)$,$g_i$表示$f_i+p_i*w_i$,$i\to i+1$时,所有$[l,i]$区间执行$g_i:=g_i+p_i$.

考虑KTT,就是区间右移函数,单点改,查询最大值,复杂度2log.

