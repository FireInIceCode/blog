---
title: NOIWC
subtitle: 没想好
layout: post
show: true
top: false
tags:
- 笔记
---

# NOIWC2024

## Day1-lxl

### 基础知识

部分持久化,完全持久化,可合并的持久化:只能在最后一个版本改/可以在任意版本改/可以合并历史版本,版本之间连有向边分别是链,树,图

离线建操作树可以解决完全持久化

实现可持久化的三种方式:路径复制,肥节点和节点分裂.设修改和查询次数分别为$m_1$和$m_2$

#### 路径复制类似主席树状物

可以支持可合并的持久化

#### 肥节点

对每个节点用可持久化数组记录不同时间的版本,查询时在这个节点的版本序列上二分,可以实现部分可持久化,veb可以平衡到$(m_1,m_2)\log \log m_1$

对于完全可持久化,考虑版本树的括号序,相当于可以插入一对括号和在括号序列上二分,查询某个版本的值这三个操作,因为有二分要求插入log查询$O(1)$,方法是开重量平衡树(深度$\log n$,每次调整$\log n$个点),每个点维护值域区间,父亲区间$[l,r]$则两个儿子分别是$[l,mid]$和$[mid+1,r]$,另一个点的标号为$\dfrac{l+r}{2}$,则修改时修改区间和标号,查询时只要比较两个点的标号.平衡树treap/替罪羊即可.

感觉就是如何在不打标记的情况下解决平衡树在有key的情况下动态插入点.

另一种解决刚才的问题的方案是一个链表,每次插入元素取前驱后继平均值比较标号,复杂度$O(1)-O(1)$,但是精度要求节点数不超过$O(w)$,嵌套$O(1)$层复杂度$O(w^{O(1)})$,于是把序列按$B$分块,块间平衡树块内用刚才链表的方法去一个log.

感觉还挺问号,再想想.

#### 节点分裂

就是,一种波尔方式是直接可持久化数组记录所有指针

然后它每$w$个版本分一块,每次改边的时候只把边指向对面的节点版本所在块,每次新增块的时候修改连向当前块的点们,给它们增加一个修改操作

#### 可持久化平衡树

除了splay,都行/cf

替罪羊树可以部分持久化(均摊)

其他的都可以完全持久化

#### 可合并持久化的平衡树

这里定义合并是序列拼接

可以用路径复制实现平衡树的分裂合并,于是可以支持区间复制

但是复杂度仍然是$\log len$,于是受限

treap的合并可持久化:不能存随机值否则反复复制一个点随机值是一样的,于是按子树大小随机就行了,复杂度未知反正没人会卡

### P8263 [Ynoi Easy Round 2020] TEST_8

倍增合并,treap显然复杂度是$\log^2 n$的,过不了,但是WBLT合并大小为$a,b$的树复杂度是$\log \dfrac{a}{b}$.于是复杂度变为单log

### P8524 [Ynoi2078] 《A theory of consciousness from a theoretical computer sciencepers

直接做的化,用可合并持久化平衡树,然后对除以$2$维护每个数除了$1,2,\ldots$次的$\log n$个数,就复杂度单log\了.

然而空间俩log爆炸了,考虑因为我们不需要维护之前的版本于是直接每$\dfrac{n}{\log n}$次重构,或者直接智能指针就做完了.

### CF702F T-Shirts

设$f_{i,j}$为从$i$开始往后走有$j$元最后的答案,转移发现是区间复制和区间加,结束啦.

### Hdu5118 Gre Words Once More

同上,可持久化平衡树的区间复制维护dp

DAG链剖分!

### 树套可持久化平衡树

#### 可持久化作为标记:BZOJ3946

开两个可持久化平衡树分别维护当前节点所有字符串都被加了序列$s$和当前节点序列的lcp序列$t$,下传直接区间复制,于是外层线段树序列,查询在内层多个持久化平衡树二分.复杂度$q\log^3 n$

可以优化到俩log,考虑差分,维护相邻两个字符串的lcp长度,答案就是区间$\min$,仍然用上面方法维护字符串,每次修改只需要重新计算边界的$f$,中间的是区间加.

#### 可持久化作为信息:CF1340F Nasty and CBs

可持久化平衡树维护区间括号hash,合并就是区间查询相等和区间拼接拆分
 
### 可持久化可并堆

斜二项堆介绍...

#### BZOJ3489

> 强制在线

每个数贡献一个区间,变成了二维平面上矩形取max单点求值,于是可以线段树套堆给它可持久化掉

#### Luogu7651

考虑对单个点求直接持久化线段树扫描线就行,求前$k$近就不断删最小的即可.


## Day1-xtq

不听了

## Day1-营员交流内容

### 浅谈一种互质数对与最大公约数的维护算法

#### 算法

互质数对与最大公约数的维护算法?

$P(x)$为$x$最大质因子

基本解决问题是,要求初始全为$0$的序列$a_n$,要求你进行$m$次修改,使得对于任意$i\in [1,n]$存在时刻$t$满足$\forall j,b_j=[i \perp j]/\gcd(i,j)$,应用类似莫队的一个玩意.

基本思想是拆贡献,$[i\perp j]=1-[\exists p\ne 1,p\vert i,p\vert j]$,$\gcd(i,j)=\prod_p p^c [p^c\vert i,j][p^{c+1}\not \vert i,j]$

于是直接爆搜决定$p$,对于互质的情况,dfs状态为$(i,x)$表示小于$x$的部分决定乘上的乘积为$i$,当前要决定$p_x$是否被乘上.当乘上素数$p_x$的时候把$p_x$的倍数$a_j(j=kp_x)$设为$0$,回溯时撤销,当$ip>n$的时候直接退出,得到一个爆搜算法.正确性显然.

对于$gcd$的情况一样爆搜,只不过对$p$应该枚举$c$表示$p$的次数,剩下的完全一样.

对于复杂度显然两个复杂度都低于$\sum_i \dfrac{n}{P(i)}\approx n\sqrt n$(在$10^6$附近,只维护互质对的情况常数较小)

#### 例题

> 给定$a_n$,$q$次给定$l,r,x$询问$\{a_{\gcd(x,i)},i\in[l,r]\}$的最大子段和.

直接用上面的方法转化成单点改区间最大子段和即可.复杂度$n\sqrt n\log n$

### 浅谈一些信息合并的处理方式

典

#### 无旋treap带值域交合并

[网上其实早就有了](https://www.cnblogs.com/-Wallace-/p/merge-treaps.html)

基本就是,要合并两棵树,考虑两个根节点$a,b$,设$a$的优先级高(作为根),则把$b$按$a$的权值分裂,左右递归下去.



#### 线段树合并卡空间



### 线性拟阵奇偶

啥玩意??????

### 浅谈静态数据结构的合并与分裂

#### 点分树,边分树合并,静态toptree合并

点分树先建哈夫曼树二度化,然后两个都直接照抄线段树合并即可.

静态toptree深度也是$\log n$的,现在要合并$u\to v$的链,要分情况讨论:
- $u,v$有祖先关系
- $u,v$无祖先关系
- $u,v$分别在重儿子左右的两个 rake tree 上。
- $u,v$其中一个是重儿子，即不在 rake tree 上。
- $u,v$在同一个rake tree 上

要处理一个叶子和一个子树的合并,维护簇界点之间路径的标记和簇其他部分的标记.

#### 点分树,边分树,toptree分裂

点分树,边分树因为到重心这一信息的不可分裂性通常不能分裂,能分裂当且仅当信息可以分裂,如信息是线段树用线段树分裂

toptree按子树分裂:设关于$u$分裂,$u$的子树表现为compress tree在他右侧的点,以及这些点的rake tree,那直接对它所在compress tree分裂是简单的,对自己所在的rake tree把自己分出来也只要$O(\log n)$的修改量,于是就分裂了.

对于链的分裂,他说只用compress的双层toptree,感觉是直接造了一个leafy的全局平衡二叉树/cf,而全局平衡二叉树拿走一条链是简单的.

### 范围修改查询问题相关算法及其应用

线段树能维护修改和区间信息都为半群的问题

#### lxl的离线范围修改查询算法

> 问题描述为给定若干点,若干次针对某个集合的修改和查询,都是半群信息

定义等价关系为两个点所属的修改和查询集合相同.由此定义出等价类.定义一个划分$R_{l,r}$为仅考虑$[l,r]$中的修改查询得出的等价类集合的集合.

考虑维护有根森林,即每个叶子为原问题中的点,一个等价类为一棵子树,每个节点子树和,子树修改标记,合并等价类就是建一个父亲把等价类挂上去,拆分就是把父亲删掉并下传修改标记,而可以用这种方式在不同的$R_{l,r}$划分之间移动.假设现在要处理$R_{l,r}$这个问题,先移动森林状态到$R_{l,mid}$递归,再移动到$R_{mid+1,r}$递归即可.

然后设$F(x)$是$x$个操作最多可以把点分成多少等价类,$B$是最大的$x$满足$F(x)\le n$,于是可以$B$个操作分一块,复杂度$T(n,m)=\dfrac{m}{B}T_1(B),T_1(n)=2T_1(\dfrac{n}{2})+O(F(n))$,对于半平米,圆可以做到$m\sqrt n$,对任意集合可以做到$\dfrac{nm}{\log n}$,对序列可以$m\log n$

#### 分块旋转扫描线

略

### 浅谈一类树上范围相关问题

#### 树剖

理解为树上链分治结构

> 单点询问,树链距离$d$以内的点加. 范围都是$10^5$

重链剖分,考虑一次操作的影响,发现会对重链上的区间的点的轻子树作前$d$层加,此外端点处有对当前点的子树前$d$层加或向祖先方向的前$d$层加.

那么后两种都相当于给定$u$,对范围内点$v$加$d-dis(u,v)$,于是能做了:用树套树维护标记,查询时要查到根的路径上每个链头的标记,子树内点的标记,祖先点的标记三种,直接做3log,把树剖换成全局平衡二叉树是2log.

#### 毛毛虫剖分

> 对一条链距离为$d$以内的点加,对一条链距离为$d$以内的点求和,子树加子树和链加链和.
> $d$为常数且$d\le 3$

原来只见过距离为$1$的毛毛虫剖分,不过容易发现扩展是平凡的,假设距离为$d$,要给当前重链标号,自然先给重链标号,再给挂在当前重链的所有轻儿子的前$d$级后代标号,再递归下去,则每条链只有前$d$个标号不连续.$d$一般很小不然复杂度就爆了.

#### 点分树维护传递性问题

> $n$点树,一开始均未激活,若$i$激活会激活距离$r_i$以内的点,$q$次询问激活一点后被激活点的点权和.

todo

#### Toptree:P8498 树上邻域数点

建toptree,设$f_{u,0/1,d}$表示距离簇$u$内距离左/右界点$d$以内的信息,$g_{u,0/1,d}$表示簇$u$外距离左/右界点距离为$d$以内的点的信息,则询问$u$时,找到任意一条边$u,v$,然后找到最浅的完全被询问的区域包含的簇$x$,则答案就是$x$的两个界点各向外一部分以及簇$x$自身合并出来的,于是可以先把自身和一个端点的合起来,查询时只需要一次.

问题变成如何求$f$和$g$,$f$根据$f$的定义显然可以直接用rake和compress得到,而$g$考虑对簇换根,假设现在祖先的$g$已经求出,则簇$u$的内容就是父亲的$g$和兄弟的$f$的合并.

$f$的$d$只要开到簇路径长度,$g$的$d$只要开到父亲的簇路径长度,总复杂度$n\log n$

## Day2-qlr

### CF1753C

nfls里面有

### Yogyakarta Elevators

考虑$m$很小,而且图的边集是若干团,于是考虑线图把点边互换,以电梯为点,每个楼把所有经过这个楼的电梯连起来,于是一个区间连通的条件是只保留这个区间中的边只有一个不为单点的连通块.

然后直接扫描$r$,只添加$[1,r]$之间的楼的边,则图只要保留最大生成树,而这个只有本质不同的$O(m)$种方案,用并查集维护复杂度$nm\alpha(n)$

### CF1753D

对这种题想到看成格子移动的模型,则对每个砖块$(a,b),(a,b+1)$,连边$(a,b-1)\to (a,b+1),(a,b)\to (a+1,b+1),(a,b)\to (a-1,b+1)$,各个方向连起来,跑最短路即可.注意到黑白染色黑白格独立,找两个相邻格子最短路相加就是答案.

然后为什么是对的,即证明一个格子不会移动两次,若出现过这种情况,则一定存在某个时刻它已经空出这个位置,就不会有后面的移动了.

### CF1750F

见count

### ARC148D

考虑$2n$为偶数,所以最后两布一定是ALice先Bob后,于是若最后两个数$x,y$满足$y-x\ne x-y$即$2x\ne 2y$不相等Alice的两种方案总能赢一个,于是最后两个数相等,那么照着归纳,假设已经有最后$2k$步必须$2x=2y$的数可以匹配,则对于倒数$2k+1$和$2k+2$两个数,显然如果不相等则交换这两个数的情况就不一样了,于是Bob想获胜必然满足开始状态可以一一配对,每对满足$2a=2b\pmod M$.

而当前所有数都满足之后,直接模拟,看最后会得到$\dfrac{M}{2}$或$0$即可,做完了.

### ARC151E

注意不能删成空

则发现如果没有公共子串那么先转到它一定是最优的,sam即可

如果没有相当于先删到一个字符,然后不断变成另一个字符变到$Y$有的最后再变回去,那就是相邻两字符连边跑最短路.

### BJOI2018 染色

容易发现奇环无解,现在是二分图.

容易把连通块分别判断,同时一度点不影响任何事,现在是无一度点的连通图.

然后现在一个连通块应该有一些环,发现对于一个长$n$的偶环我们可以确定其上的$n-2$个点,选一条长$n-2$的链全放$\{1,2\}$,剩下两个点放$\{1,3\}$和$\{2,3\}$,设链与$\{1,3\}$相连的头为$u$,则容易发现$u$若选$1$则链尾是$2$,与$u$相连的另一个点只能是$3$,最后一个点$\{2,3\}$就没有可选的了,于是固定了一条链.

由此可以得到,一个连通块不可能有两个交的点数小于等于$2$的环,否则分别固定一条链就给它搞死了.于是现在是彼此之间交路径长度大于$1$的环.

再看,度数大于等于$4$意味着两个环的唯一交点肯定寄了,同样发现多于两个三度点也无解,最后只有两个三度点的情况,图的形态是两个点之间三条路径.

最后,如果存在$\ge 2$条路径边数$>2$也无解,考虑任意一个偶环可以确定$n-2$个点,于是把两个$n-2$个点的部分重合一下就死了.这样路径长度为奇数的不能是大于$2$的就不存在了(重边应该扔了),路径长度为偶数的只能是恰好两条路径长恰为$2$,就做完了.

有解情况:删完一度点后啥也不剩,环,三度点且两条路径长度为$2$.


### IOI2023 封锁时刻

第一种情况是没有点贡献$2$,则$x,y$独立,中间切开,直接贪心就是对的.

第二种情况是存在点贡献$2$,那么如果是序列应该是把每个点看成投入$d_1$获得代价$1$,再投入$d_2-d_1$的物品做贪心,此时可以分成两组,对于$d_2-d_1>d_1$的部分直接是凸函数max+卷积,对于$d_2-d_1<d_1$因为是上凸容易证明最多只有一个没有选满,排序后枚举选了多少个$2$即可.

而对于当前树形的问题则有依赖要求.考虑如果儿子比父亲劣(代价比父亲高)则依赖被贪心满足,则发现只有$x\to y$的链上这个条件不满足,而如果存在有点贡献$2$这条链上一定每个点都至少贡献$1$,于是就做出来了.

### P9605 [IOI2023] 机器人比赛

考虑把$0,1$单独拿出来,$2,3,4,5$分别看作上下左右标记.

首先要求最短路,作为第一阶段,考虑bfs,需要有一种方法逐层扩展节点.从左上角开始bfs,先把左上角指向下(或右)并朝该方向移动一格.每当第一次到大一个节点,将移动到的格子向回指向父亲(唯一一个指向自己的格子)并移动到父亲;若当前节点不是第一次到达,不断将指针逆时针旋转,若指向格子未访问过就访问,若是父亲就退回去,于是每次最靠右下的所有格子会向外扩展一个距离,同时机器人最终回到左上角,是一个逐层加深的dfs过程,并且任意时刻所有格子的指针为边构成机器人为根的根向树,按照访问顺序构成以左上角为根的bfs树.当机器人到达右下角时到第二阶段.

第二阶段要给最短路染色,现在是以右下角为根的根向树,则顺着树边dfs,到达叶子时如果叶子是左上角就设为$1$否则设为$0$,然后开始回溯,回溯过程若相邻节点为$1$设为$1$否则设为$0$,容易发现满足要求.

