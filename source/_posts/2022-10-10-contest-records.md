---
title: 比赛记录
subtitle: 挂分记录
layout: post
show: true
istop: false
tags: 
- 杂项
- 日志
- 咕咕
---

# 比赛记录

## 某某Contest

很久以前写下zscontest的编号...zs是什么啊?

是不是振声啊

### zscontest [博弈论] [打表]

> $n\times m$ 的网格上有若干硬币,初始时全部为反, $q$ 次翻转一个矩形并询问,若两人轮流操作,每次先选择一枚正面硬币 $(x,y)$ ,再选择一个 $(a,y),a<x$ 或 $(x,b),b<y$ ,同时翻转这两个格子的硬币,不能操作的人输,是先手必胜还是后手必胜.
> 
> $n,m\le 10^9,q\le 10^5$ 

首先结论:每一枚硬币是独立的.这个操作实际上相当于硬币可以向左或向下移动若干步,两枚硬币碰到一起就一起消失,那么考虑假设硬币不会消失的情况和这个是等价的,因为若选择移动多枚硬币位置相同,后手仍然以相同方式移动这个位置到先手移动到的位置是不会让局面更优也不会更劣等,所以是等价的.

于是每一枚硬币分别的SG值求出来异或,打表SG值和其矩形前缀和找规律吧.

### zscontest2 [复杂度]

> 有 $n$ 个数对 $(a,b)$ 构成的集合,给定 $m$ , $k$ 和集合,求最小的 $t$ 满足有至少 $k$ 个不同子集的 $\sum a+bt\ge m$ .
> 
> $n,k\le 10^5,a,b,m\le 10^9$ 

二分答案是容易想到的,于是变成了求有多少个子集和大于 $m$ 或子集和的第 $k$ 大.

一般rank总是比kth容易,发现k并不到 $2^n-1$ ,我们的复杂度一定是相关 $k$ 的,然后就不会了.

一个我没见过的经典题求所有子集合的第 $k$ 大,解法是爆搜子集,当前结果大于等于 $m$ 就返回,否则把个数加一继续搜.

这个复杂度的分析是重点,qyc一开始说因为每次递归让方案数变大1,最多到 $k$ (不然直接停),于是就解决了,但实际上,若初始状态为全部不选,连续若干个不选并不会增加方案数,正确的做法是先递增排序,这样如果前面的不选后面的更选不了可以直接跳,就仍然有每次递归方案数变大1了.

然而这个题还有负数,考虑我们搜大于等于 $m$ 的子集,就要满足:

- 一旦和低于 $m$ 就能退出

- 若这个不选以后的也不能选

所以初始状态为选所有正数不选所有负数,并按绝对值排序,这样做保证如果当前这一位相比初始状态不能改变以后的也不行可以直接跳.

### zscontest3 [直径]

> 单点修改边权,查子树直径. $n\le 10^5$ .

合并直径是简单的,四个端点两两比一比就好了,因为要查距离并支持修改所以用BIT维护点到根距离,并用建在欧拉序上的线段树维护直径解决问题.

另一种做法是静态toptree说能1log,但我还不会静态toptree,需要学习一下.

### zscontest4 [FFT] [多项式]

> 给一个 $V\le 2$ 个点,识别括号和空格的自动机,字符集为 $(,),space$ ,求有多少种从点 $s$ 到点 $t$ 走 $n$ 的方案行成合法括号串. 
> 
> $n\le 10^5$ 

万恶多项式,打完 $n\le 1000$ 走人.

等学了分治FFT再来.


## 22.10.10 VP CF1198 Codeforces Round #576 (Div. 1)

和wjw,难度感觉不大到Div1.

过程大概是先切A,然后看一眼B直接SegmentTreeBeats没冲出来发现自己不会STB///fn.然后去开C,D,E,F,发现E好像可做.仔细一想是个套路网络流把它冲出来了,然后去做B写了个更简单的O(n)做法.比赛结束.

wjw切了 $B\to A\to D$

### A MP3

智障题.

### B.Welfare State

> 单点改,区间取max. $n,q\le 2\times 10^5$

写吉老师线段树的都降智.

直接离线,对每个点考虑,一个点的值是它最后一次修改的值和从这一次修改开始往后这一段时间取max的最大值.复杂度线性.

所以CF这种短时间比赛反而更不能急着码,多想想是不是可以写的简单点.

### C.Matching vs Independent Set

> 给一个 $3n$ 个点, $m$ 条边的图,你给出一个 $n$ 个点的独立集或一个 $n$ 个边的匹配.
> 
> $n\le 10^5,m\le 5\times 10^5$ .多组询问.

qyc的做法,任意求一棵dfs树,如果叶子多于 $n$ 个就选叶子,否则现在叶子少于 $n$ 个,除了叶子每个点都可以和自己的父亲/儿子匹配,于是至少有 $n$ 个边.就结束了.

wjw看了看slime的做法,说的是直接贪心求匹配(任意加边),如果够 $n$ 条直接结束,否则因为只使用了少于 $2n$ 个点,且剩下的点已经选不出相邻的两个点形成匹配,所以剩下的一起当独立集即可.

### D. Rectangle Painting 1

> 给一个 $n\times n$ 的网格图,一开始格子有黑有白,每次你可以花费 $\max w,h$ 的代价将一个 $w\times h$ 的矩形染白,求全白的最小代价.
> $n\le 50$

降智题

做法是,要么一个操作染了全局,否则必然有一个未染色的分界点(分界成左上和右下),然后可以递归下去做.这样复杂度 $n^5$ .

还是不太敢想这种 $n^5$ 复杂度的东西啊///kk,明明是可以很简单的.

### E. Rectangle Painting2

> 给一个 $n\times n$ 的网格图,一开始格子有黑有白,每次可以花费 $\min w,h$ 的代价将一个 $w\times h$ 的矩形染白,求全白的最小代价.
> 
> 黑色格子的给出方式是输入 $m$ 个矩形,黑色格子为这 $m$ 个矩形的并.
> 
> $n\le 10^9,m\le 50$ .

套路题.首先我们显然会每次将染一行或一列全染白,于是就成了选若干行和列覆盖所有位置.这个模型有点像网络流,然后发现一个最小割结束战斗(行点列点,行向列连 $inf$ ,起点,终点向行列连1).然后突然发现黑色格子是由矩形给出的.不过没关系,直接离散化, $m$ 个矩形在平面上切割刀连通块数是 $m^2$ 的,所以就是 $4m$ 个点, $m^2+2m$ 个边冲就好了.

### F. GCD Groups 2

> 给出 $n$ 个整数,要将它们划分成两个集合使得这两个集合各自 $\gcd$ 为1,求方案或判断无解.
> 
> $n\le 10^5$

有点意思.

智慧法:从前往后扫,考虑第一个集合,如果当前这个数不是 $\gcd$ 的倍数就加入这个一集合,这样 $gcd$ 一定变小.然后一遍肯定不对就randomshuffle.正确的原因是, $10^9$ 的不同质因数个数只有9, $10^9$ 到质数大约有 $5\times 10^7$ 个很多,所以很难出现一种状况让一整个集合有一个共同质因子.

官方正解(搬运翻译):

首先,你只要用 $9$ 个数干掉每一个因子.所以有解情况下必然由一种情况使得在其中一个集合大小不超过9.

然后随机取两个数钦定它们在不同的集合中,这样同一个集合的概率很小(因为其中一个集合只有9个数).然后对一个集合做状压dp(压掉当前还活着哪些质因子).这样做复杂度是 $n\times 2^{2k}$ .

最后实际不需要全部 $n$ 个数做这个dp,可以对每个素数取 $2k$ 个,这个数量可以杀掉其他所有素数,无论如何会有一个空余的可用.复杂度 $k^2\times 2^{2k}$ .

官方正解真阴,随机化万岁!.

## 22.10.12 VP CF1736 Codeforces Round #825 (Div. 2)

又是降智的一天呢!

### A.Make A Equal to B

智障题

### B.Playing with GCD

没切Div2B,输麻从此刻开始///fn///fn///fn

> 给定序列 $a_n$ ,判断是否有可能构造序列 $b_{n+1}$ 满足 $a_i=\gcd(b_i,b_{i+1})$ .
> 
> $\sum n\le 10^5$

把每一个数看作向量, $\gcd$ 是对向量每个元素取 $\min$ ,考虑如果你的向量 $b_i$ 的一个元素同时比 $a_i$ 和 $a_{i-1}$ 的对应元素大,那么一定是不优的(你不能用它做取 $\min$ 了).所以结论是 $b_i=\operatorname{a_i,a_{i-1}}$ ,然后有可能不行,所以再 check 一遍.

### C1. Good Subarrays (Easy Version)

写麻烦做法,继续寄///ll

> 给定序列 $a_n$ ,求有多少子区间 $[l,r]$ 满足 $\forall i\in [l,r],\ a_i\ge {i-l+1}$
> 
> $\sum n\le 2\times 10^5$ ,多组询问

赛时写了个,从后面往前扫,每次给当前后缀区间减1,二分第一个小于 $0$ 的位置.总结应该是,还是太着急写代码,明明想到某些单调性但觉得这个不难写就直接冲了.

考虑每个位置减去下标,问题变成 $\forall i\in [l,r]\ ,a_i\ge -l+1$ .

然后考虑每个左端点,合法的右端点是一个前缀,并且每个左端点对应的合法右端点是单增的,那么可以直接从上一个左端点的右端点开始往后扫就能处理出每个位置为左端点对应的右端点,把这个数组记为 $r$ .

不过看起来不给前后缀区间减一没有关系,重点是要发现右端点单增可以直接扫///fn

### C2. Good Subarrays (Hard Version)

接着刚才的做法,区别是加了独立的单点询问.

发现改小是直接二维数点(平面上线段,求矩形内线的总长),改大比较问号,我们根本不会追溯修改.

然后我在错误的道路上越走越远了.

然后汪娟突然跳出来:改大不是比改小简单吗?

是的!我们是智障!///fn,因为改大的时候,你只会改一个数,所以对一个 $i$ ,可以处理若 $r_i+1$ 被改对了那么新的 $r_i$ 是几,就做完了.

CF官方题解上改大和改小是同一个处理///jy厉害了

todo